<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Video Layer Composer</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      color: white;
    }

    #container {
      position: relative;
      width: 100%;
      height: 100vh;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      z-index: 100;
      max-width: 300px;
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-size: 12px;
    }

    input[type="range"] {
      width: 100%;
      margin-bottom: 5px;
    }

    input[type="file"] {
      width: 100%;
      margin-bottom: 10px;
    }

    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
      margin-bottom: 5px;
    }

    button:hover {
      background: #45a049;
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
    }

    #layersList {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #333;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
    }

    .layer-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 3px;
      cursor: pointer;
    }

    .layer-item.selected {
      background: rgba(76, 175, 80, 0.3);
    }

    #info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background: #333;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }

    .progress-fill {
      height: 100%;
      background: #4CAF50;
      transition: width 0.3s ease;
    }

    .export-controls {
      border: 1px solid #333;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="controls">
      <h3>3D Video Layer Composer</h3>
      <input type="text" id="sceneName" placeholder="Scene Name">

      <div class="control-group">
        <label>Add Video Layer:</label>
        <input type="file" id="videoFile" accept="video/*">
        <button onclick="addVideoLayer()">Add Layer</button>
      </div>

      <div class="control-group">
        <label>Position X: <span id="xValue">0</span></label>
        <input type="range" id="xPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

        <label>Position Y: <span id="yValue">0</span></label>
        <input type="range" id="yPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

        <label>Position Z (Depth): <span id="zValue">0</span></label>
        <input type="range" id="zPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">
      </div>

      <div class="control-group">
        <label>Transparency: <span id="alphaValue">1.0</span></label>
        <input type="range" id="alpha" min="0" max="1" step="0.1" value="1" oninput="updateTransparency()">

        <label>Scale: <span id="scaleValue">1.0</span></label>
        <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1" oninput="updateScale()">
      </div>

      <div class="control-group">
        <label>Rotation X: <span id="rotXValue">0</span></label>
        <input type="range" id="rotX" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

        <label>Rotation Y: <span id="rotYValue">0</span></label>
        <input type="range" id="rotY" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

        <label>Rotation Z: <span id="rotZValue">0</span></label>
        <input type="range" id="rotZ" min="-180" max="180" step="1" value="0" oninput="updateRotation()">
      </div>

      <div class="control-group">
        <button onclick="playAll()">Play All</button>
        <button onclick="pauseAll()">Pause All</button>
        <button onclick="resetCamera()">Reset Camera</button>
      </div>

      <div class="export-controls">
        <h4>Export Settings:</h4>
        <label>Frame Rate: <span id="fpsValue">12</span> fps</label>
        <input type="range" id="fps" min="6" max="30" step="1" value="12" oninput="updateFpsValue()">
        
        <label>Duration: <span id="durationValue">3</span> seconds</label>
        <input type="range" id="duration" min="1" max="10" step="0.5" value="3" oninput="updateDurationValue()">
        
        <button id="exportBtn" onclick="exportAnimatedGLB()">Export Animated GLB</button>
        <div id="exportProgress" style="display:none;">
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <span id="progressText">0%</span>
        </div>
      </div>

      <div id="layersList">
        <h4>Layers:</h4>
        <div id="layers"></div>
      </div>
    </div>

    <div id="info">
      <div>Camera Controls: Mouse drag to orbit, scroll to zoom</div>
      <div>Export creates keyframe animations from video frames</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let videoLayers = [];
    let selectedLayer = null;
    let layerCounter = 0;

    // GLB Exporter (simplified version)
    class GLBExporter {
      constructor() {
        this.buffers = [];
        this.bufferViews = [];
        this.accessors = [];
        this.textures = [];
        this.images = [];
        this.materials = [];
        this.meshes = [];
        this.nodes = [];
        this.animations = [];
        this.scenes = [];
      }

      async exportScene(scene, options = {}) {
        const { fps = 12, duration = 3, sceneName = 'scene' } = options;
        
        // Reset arrays
        this.buffers = [];
        this.bufferViews = [];
        this.accessors = [];
        this.textures = [];
        this.images = [];
        this.materials = [];
        this.meshes = [];
        this.nodes = [];
        this.animations = [];
        this.scenes = [];

        const totalFrames = Math.ceil(fps * duration);
        const frameDuration = 1 / fps;

        // Create animations for video layers
        for (let i = 0; i < videoLayers.length; i++) {
          const layer = videoLayers[i];
          await this.createVideoAnimation(layer, totalFrames, frameDuration, i);
        }

        // Create basic scene structure
        this.createBasicScene();

        // Build final GLB
        return this.buildGLB(sceneName);
      }

      async createVideoAnimation(layer, totalFrames, frameDuration, layerIndex) {
        const video = layer.video;
        const mesh = layer.mesh;
        
        // Create image sequence from video
        const images = [];
        const canvas = document.createElement('canvas');
        canvas.width = Math.min(video.videoWidth || 512, 512);
        canvas.height = Math.min(video.videoHeight || 512, 512);
        const ctx = canvas.getContext('2d');

        // Capture frames
        for (let frame = 0; frame < totalFrames; frame++) {
          const time = (frame / totalFrames) * video.duration;
          video.currentTime = time;
          
          await new Promise(resolve => {
            video.addEventListener('seeked', resolve, { once: true });
          });

          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          const imageData = canvas.toDataURL('image/jpeg', 0.8);
          images.push(imageData);
        }

        // Create texture switching animation
        const timeValues = [];
        const textureIndices = [];
        
        for (let frame = 0; frame < totalFrames; frame++) {
          timeValues.push(frame * frameDuration);
          textureIndices.push(frame);
        }

        // Store animation data
        this.animations.push({
          name: `videoAnimation_${layerIndex}`,
          timeValues,
          textureIndices,
          images,
          mesh: mesh
        });
      }

      createBasicScene() {
        // Create a simple scene with one node per video layer
        this.scenes.push({
          name: 'Scene',
          nodes: videoLayers.map((_, i) => i)
        });

        videoLayers.forEach((layer, i) => {
          const mesh = layer.mesh;
          
          // Create node
          this.nodes.push({
            name: `VideoLayer_${i}`,
            translation: [mesh.position.x, mesh.position.y, mesh.position.z],
            rotation: [mesh.quaternion.x, mesh.quaternion.y, mesh.quaternion.z, mesh.quaternion.w],
            scale: [mesh.scale.x, mesh.scale.y, mesh.scale.z],
            mesh: i
          });

          // Create mesh
          this.meshes.push({
            name: `VideoMesh_${i}`,
            primitives: [{
              attributes: {
                POSITION: 0,
                TEXCOORD_0: 1
              },
              indices: 2,
              material: i
            }]
          });

          // Create material
          this.materials.push({
            name: `VideoMaterial_${i}`,
            pbrMetallicRoughness: {
              baseColorTexture: {
                index: i
              },
              metallicFactor: 0,
              roughnessFactor: 1
            },
            alphaMode: 'BLEND'
          });
        });

        // Create basic plane geometry
        const positions = new Float32Array([
          -1, -1, 0,
          1, -1, 0,
          1, 1, 0,
          -1, 1, 0
        ]);

        const uvs = new Float32Array([
          0, 0,
          1, 0,
          1, 1,
          0, 1
        ]);

        const indices = new Uint16Array([
          0, 1, 2,
          0, 2, 3
        ]);

        // Create accessors
        this.accessors.push(
          {
            bufferView: 0,
            componentType: 5126, // FLOAT
            count: 4,
            type: 'VEC3',
            min: [-1, -1, 0],
            max: [1, 1, 0]
          },
          {
            bufferView: 1,
            componentType: 5126, // FLOAT
            count: 4,
            type: 'VEC2'
          },
          {
            bufferView: 2,
            componentType: 5123, // UNSIGNED_SHORT
            count: 6,
            type: 'SCALAR'
          }
        );

        // Create buffer views
        this.bufferViews.push(
          {
            buffer: 0,
            byteOffset: 0,
            byteLength: positions.byteLength
          },
          {
            buffer: 0,
            byteOffset: positions.byteLength,
            byteLength: uvs.byteLength
          },
          {
            buffer: 0,
            byteOffset: positions.byteLength + uvs.byteLength,
            byteLength: indices.byteLength
          }
        );

        // Create buffer
        const totalLength = positions.byteLength + uvs.byteLength + indices.byteLength;
        const buffer = new ArrayBuffer(totalLength);
        const view = new Uint8Array(buffer);
        
        view.set(new Uint8Array(positions.buffer), 0);
        view.set(new Uint8Array(uvs.buffer), positions.byteLength);
        view.set(new Uint8Array(indices.buffer), positions.byteLength + uvs.byteLength);

        this.buffers.push(buffer);
      }

      async buildGLB(sceneName) {
        // Create JSON structure
        const gltf = {
          asset: {
            version: '2.0',
            generator: '3D Video Layer Composer'
          },
          scene: 0,
          scenes: this.scenes,
          nodes: this.nodes,
          meshes: this.meshes,
          materials: this.materials,
          accessors: this.accessors,
          bufferViews: this.bufferViews,
          buffers: [{
            byteLength: this.buffers[0].byteLength
          }]
        };

        // Add textures and images (simplified - just first frame)
        if (this.animations.length > 0) {
          gltf.textures = [];
          gltf.images = [];
          
          for (let i = 0; i < this.animations.length; i++) {
            const animation = this.animations[i];
            const firstImage = animation.images[0];
            
            gltf.images.push({
              uri: firstImage
            });
            
            gltf.textures.push({
              source: i
            });
          }
        }

        // Convert to GLB
        const jsonString = JSON.stringify(gltf);
        const jsonBuffer = new TextEncoder().encode(jsonString);
        const jsonPadding = (4 - (jsonBuffer.length % 4)) % 4;
        const jsonChunk = new Uint8Array(jsonBuffer.length + jsonPadding);
        jsonChunk.set(jsonBuffer);

        const binaryBuffer = this.buffers[0];
        const binaryPadding = (4 - (binaryBuffer.byteLength % 4)) % 4;
        const binaryChunk = new Uint8Array(binaryBuffer.byteLength + binaryPadding);
        binaryChunk.set(new Uint8Array(binaryBuffer));

        // GLB header
        const header = new ArrayBuffer(12);
        const headerView = new DataView(header);
        headerView.setUint32(0, 0x46546C67, true); // 'glTF'
        headerView.setUint32(4, 2, true); // version
        headerView.setUint32(8, 12 + 8 + jsonChunk.length + 8 + binaryChunk.length, true); // length

        // JSON chunk header
        const jsonHeader = new ArrayBuffer(8);
        const jsonHeaderView = new DataView(jsonHeader);
        jsonHeaderView.setUint32(0, jsonChunk.length, true);
        jsonHeaderView.setUint32(4, 0x4E4F534A, true); // 'JSON'

        // Binary chunk header
        const binaryHeader = new ArrayBuffer(8);
        const binaryHeaderView = new DataView(binaryHeader);
        binaryHeaderView.setUint32(0, binaryChunk.length, true);
        binaryHeaderView.setUint32(4, 0x004E4942, true); // 'BIN\0'

        // Combine all chunks
        const totalLength = header.byteLength + jsonHeader.byteLength + jsonChunk.length + binaryHeader.byteLength + binaryChunk.length;
        const result = new Uint8Array(totalLength);
        let offset = 0;

        result.set(new Uint8Array(header), offset);
        offset += header.byteLength;

        result.set(new Uint8Array(jsonHeader), offset);
        offset += jsonHeader.byteLength;

        result.set(jsonChunk, offset);
        offset += jsonChunk.length;

        result.set(new Uint8Array(binaryHeader), offset);
        offset += binaryHeader.byteLength;

        result.set(binaryChunk, offset);

        return result.buffer;
      }
    }

    // Export function
    async function exportAnimatedGLB() {
      if (videoLayers.length === 0) {
        alert('Please add at least one video layer before exporting');
        return;
      }

      const exportBtn = document.getElementById('exportBtn');
      const progressDiv = document.getElementById('exportProgress');
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');

      exportBtn.disabled = true;
      exportBtn.textContent = 'Exporting...';
      progressDiv.style.display = 'block';

      try {
        const fps = parseInt(document.getElementById('fps').value);
        const duration = parseFloat(document.getElementById('duration').value);
        const sceneName = document.getElementById('sceneName').value || 'animated_scene';

        const exporter = new GLBExporter();
        
        // Update progress during export
        const updateProgress = (percent) => {
          progressFill.style.width = `${percent}%`;
          progressText.textContent = `${Math.round(percent)}%`;
        };

        updateProgress(10);

        const result = await exporter.exportScene(scene, {
          fps,
          duration,
          sceneName,
          onProgress: updateProgress
        });

        updateProgress(100);

        // Download the file
        const blob = new Blob([result], { type: 'application/octet-stream' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${sceneName}.glb`;
        link.click();

        setTimeout(() => {
          progressDiv.style.display = 'none';
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export Animated GLB';
        }, 1000);

      } catch (error) {
        console.error('Export failed:', error);
        alert('Export failed. Please check the console for details.');
        exportBtn.disabled = false;
        exportBtn.textContent = 'Export Animated GLB';
        progressDiv.style.display = 'none';
      }
    }

    function updateFpsValue() {
      document.getElementById('fpsValue').textContent = document.getElementById('fps').value;
    }

    function updateDurationValue() {
      document.getElementById('durationValue').textContent = document.getElementById('duration').value;
    }

    // Initialize Three.js scene
    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);

      // Add lights
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Add grid helper
      const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
      scene.add(gridHelper);

      // Add axes helper
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      // Mouse controls
      addMouseControls();

      animate();
    }

    // Add mouse controls for camera
    function addMouseControls() {
      let mouseDown = false;
      let mouseX = 0;
      let mouseY = 0;

      renderer.domElement.addEventListener('mousedown', (event) => {
        mouseDown = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
      });

      renderer.domElement.addEventListener('mousemove', (event) => {
        if (!mouseDown) return;

        const deltaX = event.clientX - mouseX;
        const deltaY = event.clientY - mouseY;

        const spherical = new THREE.Spherical();
        spherical.setFromVector3(camera.position);
        spherical.theta -= deltaX * 0.01;
        spherical.phi += deltaY * 0.01;
        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

        camera.position.setFromSpherical(spherical);
        camera.lookAt(0, 0, 0);

        mouseX = event.clientX;
        mouseY = event.clientY;
      });

      renderer.domElement.addEventListener('mouseup', () => {
        mouseDown = false;
      });

      renderer.domElement.addEventListener('wheel', (event) => {
        const scale = event.deltaY > 0 ? 1.1 : 0.9;
        camera.position.multiplyScalar(scale);
        camera.position.clampLength(1, 50);
      });
    }

    // Add video layer
    function addVideoLayer() {
      const fileInput = document.getElementById('videoFile');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a video file first');
        return;
      }

      const video = document.createElement('video');
      video.src = URL.createObjectURL(file);
      video.load();
      video.loop = true;
      video.muted = true;
      video.crossOrigin = 'anonymous';

      video.addEventListener('loadeddata', () => {
        const texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(0, 0, 0);

        const layer = {
          id: layerCounter++,
          name: file.name,
          mesh: mesh,
          video: video,
          texture: texture
        };

        videoLayers.push(layer);
        scene.add(mesh);

        updateLayersList();
        selectLayer(layer);

        // Auto-play video
        video.play().catch(e => console.log('Video play failed:', e));
      });

      fileInput.value = '';
    }

    // Update layers list
    function updateLayersList() {
      const layersDiv = document.getElementById('layers');
      layersDiv.innerHTML = '';

      videoLayers.forEach(layer => {
        const layerDiv = document.createElement('div');
        layerDiv.className = 'layer-item';
        layerDiv.textContent = `${layer.id}: ${layer.name}`;
        layerDiv.onclick = () => selectLayer(layer);
        layersDiv.appendChild(layerDiv);
      });
    }

    // Select layer
    function selectLayer(layer) {
      selectedLayer = layer;

      // Update UI
      document.querySelectorAll('.layer-item').forEach(item => {
        item.classList.remove('selected');
      });

      const layerItems = document.querySelectorAll('.layer-item');
      if (layerItems[videoLayers.indexOf(layer)]) {
        layerItems[videoLayers.indexOf(layer)].classList.add('selected');
      }

      // Update controls to match selected layer
      const pos = layer.mesh.position;
      const rot = layer.mesh.rotation;
      const scale = layer.mesh.scale.x;
      const alpha = layer.mesh.material.opacity;

      document.getElementById('xPos').value = pos.x;
      document.getElementById('yPos').value = pos.y;
      document.getElementById('zPos').value = pos.z;
      document.getElementById('rotX').value = rot.x * 180 / Math.PI;
      document.getElementById('rotY').value = rot.y * 180 / Math.PI;
      document.getElementById('rotZ').value = rot.z * 180 / Math.PI;
      document.getElementById('scale').value = scale;
      document.getElementById('alpha').value = alpha;

      updateControlValues();
    }

    // Update control value displays
    function updateControlValues() {
      document.getElementById('xValue').textContent = document.getElementById('xPos').value;
      document.getElementById('yValue').textContent = document.getElementById('yPos').value;
      document.getElementById('zValue').textContent = document.getElementById('zPos').value;
      document.getElementById('rotXValue').textContent = document.getElementById('rotX').value + '°';
      document.getElementById('rotYValue').textContent = document.getElementById('rotY').value + '°';
      document.getElementById('rotZValue').textContent = document.getElementById('rotZ').value + '°';
      document.getElementById('scaleValue').textContent = document.getElementById('scale').value;
      document.getElementById('alphaValue').textContent = document.getElementById('alpha').value;
    }

    // Update position
    function updatePosition() {
      if (!selectedLayer) return;

      const x = parseFloat(document.getElementById('xPos').value);
      const y = parseFloat(document.getElementById('yPos').value);
      const z = parseFloat(document.getElementById('zPos').value);

      selectedLayer.mesh.position.set(x, y, z);
      updateControlValues();
    }

    // Update rotation
    function updateRotation() {
      if (!selectedLayer) return;

      const x = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
      const y = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
      const z = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;

      selectedLayer.mesh.rotation.set(x, y, z);
      updateControlValues();
    }

    // Update transparency
    function updateTransparency() {
      if (!selectedLayer) return;

      const alpha = parseFloat(document.getElementById('alpha').value);
      selectedLayer.mesh.material.opacity = alpha;
      updateControlValues();
    }

    // Update scale
    function updateScale() {
      if (!selectedLayer) return;

      const scale = parseFloat(document.getElementById('scale').value);
      selectedLayer.mesh.scale.set(scale, scale, scale);
      updateControlValues();
    }

    // Play all videos
    function playAll() {
      videoLayers.forEach(layer => {
        layer.video.play().catch(e => console.log('Video play failed:', e));
      });
    }

    // Pause all videos
    function pauseAll() {
      videoLayers.forEach(layer => {
        layer.video.pause();
      });
    }

    // Reset camera
    function resetCamera() {
      camera.position.set(0, 0, 5);
      camera.lookAt(0, 0, 0);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Update video textures
      videoLayers.forEach(layer => {
        if (layer.video.readyState === layer.video.HAVE_ENOUGH_DATA) {
          layer.texture.needsUpdate = true;
        }
      });

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize scene when page loads
    window.addEventListener('load', initScene);
  </script>
</body>

</html>