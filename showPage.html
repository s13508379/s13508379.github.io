<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Video Layer Composer</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      color: white;
    }

    #container {
      position: relative;
      width: 100%;
      height: 100vh;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      z-index: 100;
      max-width: 300px;
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-size: 12px;
    }

    input[type="range"] {
      width: 100%;
      margin-bottom: 5px;
    }

    input[type="file"] {
      width: 100%;
      margin-bottom: 10px;
    }

    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
      margin-bottom: 5px;
    }

    button:hover {
      background: #45a049;
    }

    #layersList {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #333;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
    }

    .layer-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 3px;
      cursor: pointer;
    }

    .layer-item.selected {
      background: rgba(76, 175, 80, 0.3);
    }

    #info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="controls">
      <h3>3D Video Layer Composer</h3>

      <div class="control-group">
        <label>Add Video Layer:</label>
        <input type="file" id="videoFile" accept="video/*">
        <button onclick="addVideoLayer()">Add Layer</button>
      </div>

      <div class="control-group">
        <label>Position X: <span id="xValue">0</span></label>
        <input type="range" id="xPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

        <label>Position Y: <span id="yValue">0</span></label>
        <input type="range" id="yPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

        <label>Position Z (Depth): <span id="zValue">0</span></label>
        <input type="range" id="zPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">
      </div>

      <div class="control-group">
        <label>Transparency: <span id="alphaValue">1.0</span></label>
        <input type="range" id="alpha" min="0" max="1" step="0.1" value="1" oninput="updateTransparency()">

        <label>Scale: <span id="scaleValue">1.0</span></label>
        <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1" oninput="updateScale()">
      </div>

      <div class="control-group">
        <label>Rotation X: <span id="rotXValue">0</span></label>
        <input type="range" id="rotX" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

        <label>Rotation Y: <span id="rotYValue">0</span></label>
        <input type="range" id="rotY" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

        <label>Rotation Z: <span id="rotZValue">0</span></label>
        <input type="range" id="rotZ" min="-180" max="180" step="1" value="0" oninput="updateRotation()">
      </div>

      <div class="control-group">
        <button onclick="playAll()">Play All</button>
        <button onclick="pauseAll()">Pause All</button>
        <button onclick="resetCamera()">Reset Camera</button>
        <button onclick="downloadOBJ()">Download OBJ</button>
        <button onclick="downloadWithTextures()">Download with Textures</button>
        <button onclick="downloadAnimated()">Download Animated (GLTF)</button>
      </div>

      <div id="layersList">
        <h4>Layers:</h4>
        <div id="layers"></div>
      </div>
    </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.min.js"></script>
  <script>
    let scene, camera, renderer, controls;
    let videoLayers = [];
    let selectedLayer = null;
    let layerCounter = 0;

    function downloadOBJ() {
      const exporter = new THREE.OBJExporter();
      const result = exporter.parse(scene);
      
      const blob = new Blob([result], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'scene.obj';
      link.click();
      
      // Clean up the URL object
      URL.revokeObjectURL(link.href);
    }

    function captureVideoFrame(video) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;
      
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      return new Promise((resolve) => {
        canvas.toBlob((blob) => {
          resolve(blob);
        }, 'image/png');
      });
    }

    async function downloadWithTextures() {
      try {
        // Create OBJ content with material references
        let objContent = `# 3D Video Layer Composer Export\n`;
        objContent += `mtllib scene.mtl\n\n`;
        
        let mtlContent = `# Material file for 3D Video Layer Composer\n\n`;
        
        const texturePromises = [];
        const textureNames = [];
        
        videoLayers.forEach((layer, index) => {
          const materialName = `video_material_${index}`;
          const textureName = `video_texture_${index}.png`;
          
          textureNames.push(textureName);
          texturePromises.push(captureVideoFrame(layer.video));
          
          // Add material definition
          mtlContent += `newmtl ${materialName}\n`;
          mtlContent += `Ka 1.0 1.0 1.0\n`;
          mtlContent += `Kd 1.0 1.0 1.0\n`;
          mtlContent += `Ks 0.0 0.0 0.0\n`;
          mtlContent += `d ${layer.mesh.material.opacity}\n`;
          mtlContent += `map_Kd ${textureName}\n\n`;
        });
        
        // Generate OBJ geometry
        let vertexIndex = 1;
        videoLayers.forEach((layer, index) => {
          const materialName = `video_material_${index}`;
          const mesh = layer.mesh;
          
          // Apply transformations
          mesh.updateMatrixWorld();
          const geometry = mesh.geometry.clone();
          geometry.applyMatrix4(mesh.matrixWorld);
          
          objContent += `\n# Layer ${index}: ${layer.name}\n`;
          objContent += `usemtl ${materialName}\n`;
          
          // Add vertices
          const positions = geometry.attributes.position;
          for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i);
            const z = positions.getZ(i);
            objContent += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`;
          }
          
          // Add texture coordinates
          const uvs = geometry.attributes.uv;
          if (uvs) {
            for (let i = 0; i < uvs.count; i++) {
              const u = uvs.getX(i);
              const v = 1.0 - uvs.getY(i); // Flip V coordinate for OBJ format
              objContent += `vt ${u.toFixed(6)} ${v.toFixed(6)}\n`;
            }
          }
          
          // Add faces
          if (geometry.index) {
            const indices = geometry.index;
            for (let i = 0; i < indices.count; i += 3) {
              const a = indices.getX(i) + vertexIndex;
              const b = indices.getX(i + 1) + vertexIndex;
              const c = indices.getX(i + 2) + vertexIndex;
              objContent += `f ${a}/${a} ${b}/${b} ${c}/${c}\n`;
            }
          } else {
            // Non-indexed geometry
            for (let i = 0; i < positions.count; i += 3) {
              const a = vertexIndex + i;
              const b = vertexIndex + i + 1;
              const c = vertexIndex + i + 2;
              objContent += `f ${a}/${a} ${b}/${b} ${c}/${c}\n`;
            }
          }
          
          vertexIndex += positions.count;
        });
        
        // Wait for all texture captures to complete
        const textureBlobs = await Promise.all(texturePromises);
        
        // Create download links for all files
        const downloads = [
          { name: 'scene.obj', blob: new Blob([objContent], { type: 'text/plain' }) },
          { name: 'scene.mtl', blob: new Blob([mtlContent], { type: 'text/plain' }) }
        ];
        
        textureBlobs.forEach((blob, index) => {
          downloads.push({ name: textureNames[index], blob: blob });
        });
        
        // Download all files
        downloads.forEach(({ name, blob }) => {
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = name;
          link.click();
          URL.revokeObjectURL(link.href);
        });
        
        alert(`Downloaded ${downloads.length} files: OBJ, MTL, and ${textureBlobs.length} texture(s)`);
        
      } catch (error) {
        console.error('Export failed:', error);
        alert('Export failed. Please try again.');
      }
    }

    async function downloadAnimated() {
      try {
        // Create a scene copy for export with video data embedded
        const exportScene = new THREE.Scene();
        const videosToEmbed = [];
        
        // Clone meshes and prepare video data for embedding
        for (let i = 0; i < videoLayers.length; i++) {
          const layer = videoLayers[i];
          
          // Create canvas to capture video data
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const video = layer.video;
          
          canvas.width = video.videoWidth || 640;
          canvas.height = video.videoHeight || 480;
          
          // Capture current frame
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Create texture from canvas
          const canvasTexture = new THREE.CanvasTexture(canvas);
          canvasTexture.flipY = false;
          
          // Clone geometry and create new material with canvas texture
          const geometry = layer.mesh.geometry.clone();
          const material = new THREE.MeshBasicMaterial({
            map: canvasTexture,
            transparent: true,
            opacity: layer.mesh.material.opacity,
            side: THREE.DoubleSide
          });
          
          const mesh = new THREE.Mesh(geometry, material);
          
          // Apply transformations
          mesh.position.copy(layer.mesh.position);
          mesh.rotation.copy(layer.mesh.rotation);
          mesh.scale.copy(layer.mesh.scale);
          mesh.name = `video_layer_${i}_${layer.name}`;
          
          exportScene.add(mesh);
          
          // Store video info for potential embedding
          videosToEmbed.push({
            name: layer.name,
            video: video,
            canvas: canvas,
            ctx: ctx
          });
        }
        
        // Export as GLTF
        const exporter = new THREE.GLTFExporter();
        exporter.parse(
          exportScene,
          function (result) {
            const blob = new Blob([result], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'animated_scene.glb';
            link.click();
            URL.revokeObjectURL(link.href);
            
            // Also export video files separately
            exportVideoFiles(videosToEmbed);
          },
          { binary: true, animations: [], embedImages: true }
        );
        
      } catch (error) {
        console.error('Animated export failed:', error);
        alert('Animated export failed. Please try again.');
      }
    }
    
    function exportVideoFiles(videosToEmbed) {
      // Export each video as a separate file for manual import
      videosToEmbed.forEach((videoData, index) => {
        const video = videoData.video;
        
        // Create a link to download the original video file
        if (video.src && video.src.startsWith('blob:')) {
          // For blob URLs, we'll capture a longer sequence
          captureVideoSequence(video, `video_${index}_${videoData.name}`);
        }
      });
      
      alert(`Exported GLTF file and ${videosToEmbed.length} video references. Note: GLTF contains static textures. For true animation, manually replace textures with video files in your 3D application.`);
    }
    
    function captureVideoSequence(video, baseName) {
      // Capture multiple frames to create a basic animation sequence
      const frameCount = 30; // Capture 30 frames
      const interval = 100; // 100ms between captures
      const frames = [];
      let currentFrame = 0;
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;
      
      const captureFrame = () => {
        if (currentFrame >= frameCount) {
          // Create a zip-like structure or individual files
          frames.forEach((frameBlob, i) => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(frameBlob);
            link.download = `${baseName}_frame_${String(i).padStart(3, '0')}.png`;
            link.click();
            URL.revokeObjectURL(link.href);
          });
          return;
        }
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
          frames.push(blob);
          currentFrame++;
          setTimeout(captureFrame, interval);
        }, 'image/png');
      };
      
      captureFrame();
    }

    // Initialize Three.js scene
    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);

      // Add lights
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Add grid helper
      const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
      scene.add(gridHelper);

      // Add axes helper
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      // Mouse controls
      addMouseControls();

      animate();
    }

    // Add mouse controls for camera
    function addMouseControls() {
      let mouseDown = false;
      let mouseX = 0;
      let mouseY = 0;

      renderer.domElement.addEventListener('mousedown', (event) => {
        mouseDown = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
      });

      renderer.domElement.addEventListener('mousemove', (event) => {
        if (!mouseDown) return;

        const deltaX = event.clientX - mouseX;
        const deltaY = event.clientY - mouseY;

        const spherical = new THREE.Spherical();
        spherical.setFromVector3(camera.position);
        spherical.theta -= deltaX * 0.01;
        spherical.phi += deltaY * 0.01;
        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

        camera.position.setFromSpherical(spherical);
        camera.lookAt(0, 0, 0);

        mouseX = event.clientX;
        mouseY = event.clientY;
      });

      renderer.domElement.addEventListener('mouseup', () => {
        mouseDown = false;
      });

      renderer.domElement.addEventListener('wheel', (event) => {
        const scale = event.deltaY > 0 ? 1.1 : 0.9;
        camera.position.multiplyScalar(scale);
        camera.position.clampLength(1, 50);
      });
    }

    // Add video layer
    function addVideoLayer() {
      const fileInput = document.getElementById('videoFile');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a video file first');
        return;
      }

      const video = document.createElement('video');
      video.src = URL.createObjectURL(file);
      video.load();
      video.loop = true;
      video.muted = true;
      video.crossOrigin = 'anonymous';

      video.addEventListener('loadeddata', () => {
        const texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(0, 0, 0);

        const layer = {
          id: layerCounter++,
          name: file.name,
          mesh: mesh,
          video: video,
          texture: texture
        };

        videoLayers.push(layer);
        scene.add(mesh);

        updateLayersList();
        selectLayer(layer);

        // Auto-play video
        video.play().catch(e => console.log('Video play failed:', e));
      });

      fileInput.value = '';
    }

    // Update layers list
    function updateLayersList() {
      const layersDiv = document.getElementById('layers');
      layersDiv.innerHTML = '';

      videoLayers.forEach(layer => {
        const layerDiv = document.createElement('div');
        layerDiv.className = 'layer-item';
        layerDiv.textContent = `${layer.id}: ${layer.name}`;
        layerDiv.onclick = () => selectLayer(layer);
        layersDiv.appendChild(layerDiv);
      });
    }

    // Select layer
    function selectLayer(layer) {
      selectedLayer = layer;

      // Update UI
      document.querySelectorAll('.layer-item').forEach(item => {
        item.classList.remove('selected');
      });

      const layerItems = document.querySelectorAll('.layer-item');
      if (layerItems[videoLayers.indexOf(layer)]) {
        layerItems[videoLayers.indexOf(layer)].classList.add('selected');
      }

      // Update controls to match selected layer
      const pos = layer.mesh.position;
      const rot = layer.mesh.rotation;
      const scale = layer.mesh.scale.x;
      const alpha = layer.mesh.material.opacity;

      document.getElementById('xPos').value = pos.x;
      document.getElementById('yPos').value = pos.y;
      document.getElementById('zPos').value = pos.z;
      document.getElementById('rotX').value = rot.x * 180 / Math.PI;
      document.getElementById('rotY').value = rot.y * 180 / Math.PI;
      document.getElementById('rotZ').value = rot.z * 180 / Math.PI;
      document.getElementById('scale').value = scale;
      document.getElementById('alpha').value = alpha;

      updateControlValues();
    }

    // Update control value displays
    function updateControlValues() {
      document.getElementById('xValue').textContent = document.getElementById('xPos').value;
      document.getElementById('yValue').textContent = document.getElementById('yPos').value;
      document.getElementById('zValue').textContent = document.getElementById('zPos').value;
      document.getElementById('rotXValue').textContent = document.getElementById('rotX').value + '°';
      document.getElementById('rotYValue').textContent = document.getElementById('rotY').value + '°';
      document.getElementById('rotZValue').textContent = document.getElementById('rotZ').value + '°';
      document.getElementById('scaleValue').textContent = document.getElementById('scale').value;
      document.getElementById('alphaValue').textContent = document.getElementById('alpha').value;
    }

    // Update position
    function updatePosition() {
      if (!selectedLayer) return;

      const x = parseFloat(document.getElementById('xPos').value);
      const y = parseFloat(document.getElementById('yPos').value);
      const z = parseFloat(document.getElementById('zPos').value);

      selectedLayer.mesh.position.set(x, y, z);
      updateControlValues();
    }

    // Update rotation
    function updateRotation() {
      if (!selectedLayer) return;

      const x = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
      const y = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
      const z = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;

      selectedLayer.mesh.rotation.set(x, y, z);
      updateControlValues();
    }

    // Update transparency
    function updateTransparency() {
      if (!selectedLayer) return;

      const alpha = parseFloat(document.getElementById('alpha').value);
      selectedLayer.mesh.material.opacity = alpha;
      updateControlValues();
    }

    // Update scale
    function updateScale() {
      if (!selectedLayer) return;

      const scale = parseFloat(document.getElementById('scale').value);
      selectedLayer.mesh.scale.set(scale, scale, scale);
      updateControlValues();
    }

    // Play all videos
    function playAll() {
      videoLayers.forEach(layer => {
        layer.video.play().catch(e => console.log('Video play failed:', e));
      });
    }

    // Pause all videos
    function pauseAll() {
      videoLayers.forEach(layer => {
        layer.video.pause();
      });
    }

    // Reset camera
    function resetCamera() {
      camera.position.set(0, 0, 5);
      camera.lookAt(0, 0, 0);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Update video textures
      videoLayers.forEach(layer => {
        if (layer.video.readyState === layer.video.HAVE_ENOUGH_DATA) {
          layer.texture.needsUpdate = true;
        }
      });

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize scene when page loads
    window.addEventListener('load', initScene);
  </script>
</body>

</html>