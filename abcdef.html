<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Video Scene</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let videoLayers = [];
    const layersData = [
  {
    "name": "allimg_kenburns.mp4",
    "videoSrc": "",
    "position": {
      "x": 0,
      "y": 0,
      "z": 0
    },
    "rotation": {
      "x": 0,
      "y": 0,
      "z": 0
    },
    "scale": 1,
    "alpha": 1
  }
];

    function createVideoLayer(layer) {
      if (!layer.videoSrc) return; // skip if no src
      const video = document.createElement('video');
      video.src = layer.videoSrc;
      video.loop = true;
      video.muted = true;
      video.crossOrigin = 'anonymous';
      video.autoplay = true;
      video.playsInline = true;
      video.load();
      video.play().catch(() => {});

      video.addEventListener('loadeddata', () => {
        const texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          opacity: layer.alpha,
          side: THREE.DoubleSide
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(layer.position.x, layer.position.y, layer.position.z);
        mesh.rotation.set(layer.rotation.x, layer.rotation.y, layer.rotation.z);
        mesh.scale.set(layer.scale, layer.scale, layer.scale);
        scene.add(mesh);
        videoLayers.push({ mesh, video, texture });
      });
    }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add lights
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Add grid and axes helpers
      const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
      scene.add(gridHelper);
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      // Add video layers
      layersData.forEach(createVideoLayer);
    }

    function animate() {
      requestAnimationFrame(animate);
      // Update video textures
      videoLayers.forEach(layer => {
        if (layer.video.readyState === layer.video.HAVE_ENOUGH_DATA) {
          layer.texture.needsUpdate = true;
        }
      });
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.addEventListener('load', () => {
      init();
      animate();
    });
  </script>

</html>