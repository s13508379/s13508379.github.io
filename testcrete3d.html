<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>桌面 AR 視頻合成器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #ar-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #camera-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-height: 80vh;
            max-width: 400px;
            overflow-y: auto;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls.collapsed {
            height: 50px;
            overflow: hidden;
        }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .control-header h2 {
            margin: 0;
            font-size: 18px;
        }
        
        .collapse-btn {
            background: transparent;
            border: 1px solid #666;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 16px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #45a049;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .danger-btn {
            background: #f44336;
        }
        
        .danger-btn:hover {
            background: #d32f2f;
        }
        
        .primary-btn {
            background: #2196F3;
        }
        
        .primary-btn:hover {
            background: #1976D2;
        }
        
        input[type="file"] {
            margin: 10px 0;
            color: white;
        }
        
        .video-item {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .video-item h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #81C784;
            font-size: 14px;
            word-break: break-all;
        }
        
        .control-group {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            width: 60px;
            font-size: 12px;
            color: #ccc;
        }
        
        .control-group input[type="range"] {
            flex: 1;
            height: 5px;
            border-radius: 5px;
            background: #333;
            outline: none;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .control-group input[type="number"] {
            width: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #camera-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }
        
        .camera-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .button-group button {
            flex: 1;
            min-width: 80px;
        }
        
        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="ar-container">
        <video id="camera-video" autoplay playsinline></video>
        <canvas id="three-canvas"></canvas>
    </div>
    
    <div id="controls">
        <div class="control-header">
            <h2>AR 視頻控制面板</h2>
            <button class="collapse-btn" onclick="toggleControlPanel()">收起</button>
        </div>
        
        <div class="section">
            <h3>視頻載入</h3>
            <input type="file" id="video-input" accept="video/*" multiple>
            <button onclick="loadVideos()">載入選擇的視頻</button>
        </div>
        
        <div class="section">
            <h3>全局控制</h3>
            <div class="button-group">
                <button onclick="togglePlayAll()">全部播放/暫停</button>
                <button onclick="resetAllPositions()">重置所有位置</button>
                <button onclick="arrangeInCircle()">圓形排列</button>
                <button onclick="arrangeInGrid()">網格排列</button>
            </div>
        </div>
        
        <div class="section">
            <h3>已載入視頻</h3>
            <div id="video-list"></div>
        </div>
    </div>
    
    <div id="camera-controls">
        <button class="camera-btn primary-btn" onclick="toggleCamera()">
            <span id="camera-btn-text">開啟攝像頭</span>
        </button>
        <button class="camera-btn" onclick="switchCamera()">切換攝像頭</button>
        <button class="camera-btn" onclick="toggleBackground()">切換背景</button>
    </div>
    
    <div id="status">準備就緒</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 全局變量
        let scene, camera, renderer;
        let videoObjects = [];
        let cameraStream = null;
        let currentDeviceId = null;
        let isCameraOn = false;
        let showBackground = true;
        let animationId = null;
        
        // Three.js 初始化
        function initThreeJS() {
            // 場景
            scene = new THREE.Scene();
            
            // 相機
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 5;
            
            // 渲染器
            const canvas = document.getElementById('three-canvas');
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0); // 透明背景
            
            // 光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // 添加輔助網格（可選）
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            gridHelper.visible = false; // 默認隱藏
            scene.add(gridHelper);
            
            // 事件監聽
            window.addEventListener('resize', onWindowResize);
            setupMouseControls();
            
            // 開始渲染
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 鼠標控制
        function setupMouseControls() {
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                scene.rotation.y += deltaX * 0.01;
                scene.rotation.x += deltaY * 0.01;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            // 滾輪縮放
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(1, Math.min(20, camera.position.z));
            });
        }
        
        // 攝像頭控制
        async function toggleCamera() {
            const btnText = document.getElementById('camera-btn-text');
            
            if (isCameraOn) {
                stopCamera();
                btnText.textContent = '開啟攝像頭';
            } else {
                btnText.innerHTML = '<span class="spinner"></span> 開啟中...';
                await startCamera();
                btnText.textContent = '關閉攝像頭';
            }
        }
        
        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        facingMode: 'user'
                    }
                };
                
                if (currentDeviceId) {
                    constraints.video.deviceId = { exact: currentDeviceId };
                }
                
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('camera-video');
                video.srcObject = cameraStream;
                
                isCameraOn = true;
                updateStatus('攝像頭已開啟');
            } catch (error) {
                console.error('攝像頭錯誤:', error);
                updateStatus('無法開啟攝像頭: ' + error.message);
                document.getElementById('camera-btn-text').textContent = '開啟攝像頭';
            }
        }
        
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            const video = document.getElementById('camera-video');
            video.srcObject = null;
            
            isCameraOn = false;
            updateStatus('攝像頭已關閉');
        }
        
        async function switchCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length <= 1) {
                    updateStatus('只有一個攝像頭可用');
                    return;
                }
                
                const currentIndex = videoDevices.findIndex(device => device.deviceId === currentDeviceId);
                const nextIndex = (currentIndex + 1) % videoDevices.length;
                currentDeviceId = videoDevices[nextIndex].deviceId;
                
                if (isCameraOn) {
                    stopCamera();
                    await startCamera();
                }
                
                updateStatus('已切換攝像頭');
            } catch (error) {
                console.error('切換攝像頭錯誤:', error);
                updateStatus('切換攝像頭失敗');
            }
        }
        
        function toggleBackground() {
            const video = document.getElementById('camera-video');
            showBackground = !showBackground;
            video.style.display = showBackground ? 'block' : 'none';
            updateStatus(showBackground ? '顯示攝像頭背景' : '隱藏攝像頭背景');
        }
        
        // 視頻載入和管理
        function loadVideos() {
            const input = document.getElementById('video-input');
            const files = input.files;
            
            if (files.length === 0) {
                updateStatus('請選擇視頻文件');
                return;
            }
            
            for (let file of files) {
                loadVideo(file);
            }
            
            updateStatus(`正在載入 ${files.length} 個視頻...`);
        }
        
        function loadVideo(file) {
            const url = URL.createObjectURL(file);
            const video = document.createElement('video');
            
            video.src = url;
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            
            video.addEventListener('loadedmetadata', () => {
                // 創建視頻紋理
                const texture = new THREE.VideoTexture(video);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.format = THREE.RGBAFormat;
                
                // 創建材質（支持透明）
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide,
                    alphaTest: 0.1
                });
                
                // 計算寬高比
                const aspectRatio = video.videoWidth / video.videoHeight;
                const geometry = new THREE.PlaneGeometry(2 * aspectRatio, 2);
                
                // 創建網格
                const mesh = new THREE.Mesh(geometry, material);
                
                // 設置初始位置
                const index = videoObjects.length;
                mesh.position.x = (index % 3 - 1) * 2.5;
                mesh.position.y = Math.floor(index / 3) * 2 - 1;
                mesh.position.z = 0;
                
                scene.add(mesh);
                
                // 保存視頻對象
                const videoObj = {
                    id: 'video-' + Date.now() + '-' + index,
                    name: file.name,
                    element: video,
                    texture: texture,
                    mesh: mesh,
                    material: material
                };
                
                videoObjects.push(videoObj);
                
                // 創建控制界面
                createVideoControls(videoObj);
                
                // 自動播放
                video.play().catch(e => {
                    console.log('自動播放失敗');
                });
                
                updateStatus(`已載入: ${file.name}`);
            });
            
            video.addEventListener('error', () => {
                updateStatus(`載入失敗: ${file.name}`);
            });
        }
        
        function createVideoControls(videoObj) {
            const container = document.getElementById('video-list');
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'video-item';
            itemDiv.id = videoObj.id;
            
            itemDiv.innerHTML = `
                <h4>${videoObj.name}</h4>
                
                <div class="button-group">
                    <button onclick="toggleVideoPlay('${videoObj.id}')">播放/暫停</button>
                    <button class="danger-btn" onclick="removeVideo('${videoObj.id}')">移除</button>
                </div>
                
                <div class="control-group">
                    <label>X:</label>
                    <input type="range" min="-10" max="10" step="0.1" 
                           value="${videoObj.mesh.position.x}"
                           oninput="updateVideoPosition('${videoObj.id}', 'x', this.value)">
                    <input type="number" min="-10" max="10" step="0.1" 
                           value="${videoObj.mesh.position.x}"
                           oninput="updateVideoPosition('${videoObj.id}', 'x', this.value)">
                </div>
                
                <div class="control-group">
                    <label>Y:</label>
                    <input type="range" min="-10" max="10" step="0.1" 
                           value="${videoObj.mesh.position.y}"
                           oninput="updateVideoPosition('${videoObj.id}', 'y', this.value)">
                    <input type="number" min="-10" max="10" step="0.1" 
                           value="${videoObj.mesh.position.y}"
                           oninput="updateVideoPosition('${videoObj.id}', 'y', this.value)">
                </div>
                
                <div class="control-group">
                    <label>Z:</label>
                    <input type="range" min="-10" max="10" step="0.1" 
                           value="${videoObj.mesh.position.z}"
                           oninput="updateVideoPosition('${videoObj.id}', 'z', this.value)">
                    <input type="number" min="-10" max="10" step="0.1" 
                           value="${videoObj.mesh.position.z}"
                           oninput="updateVideoPosition('${videoObj.id}', 'z', this.value)">
                </div>
                
                <div class="control-group">
                    <label>旋轉:</label>
                    <input type="range" min="-180" max="180" step="1" 
                           value="0"
                           oninput="updateVideoRotation('${videoObj.id}', this.value)">
                    <input type="number" min="-180" max="180" step="1" 
                           value="0"
                           oninput="updateVideoRotation('${videoObj.id}', this.value)">
                </div>
                
                <div class="control-group">
                    <label>縮放:</label>
                    <input type="range" min="0.1" max="5" step="0.1" 
                           value="1"
                           oninput="updateVideoScale('${videoObj.id}', this.value)">
                    <input type="number" min="0.1" max="5" step="0.1" 
                           value="1"
                           oninput="updateVideoScale('${videoObj.id}', this.value)">
                </div>
                
                <div class="control-group">
                    <label>透明:</label>
                    <input type="range" min="0" max="1" step="0.1" 
                           value="1"
                           oninput="updateVideoOpacity('${videoObj.id}', this.value)">
                    <input type="number" min="0" max="1" step="0.1" 
                           value="1"
                           oninput="updateVideoOpacity('${videoObj.id}', this.value)">
                </div>
            `;
            
            container.appendChild(itemDiv);
        }
        
        // 視頻控制函數
        function toggleVideoPlay(id) {
            const videoObj = videoObjects.find(v => v.id === id);
            if (videoObj) {
                if (videoObj.element.paused) {
                    videoObj.element.play();
                } else {
                    videoObj.element.pause();
                }
            }
        }
        
        function togglePlayAll() {
            const allPaused = videoObjects.every(v => v.element.paused);
            videoObjects.forEach(v => {
                if (allPaused) {
                    v.element.play();
                } else {
                    v.element.pause();
                }
            });
            updateStatus(allPaused ? '播放所有視頻' : '暫停所有視頻');
        }
        
        function updateVideoPosition(id, axis, value) {
            const videoObj = videoObjects.find(v => v.id === id);
            if (videoObj) {
                videoObj.mesh.position[axis] = parseFloat(value);
                // 同步更新輸入框
                syncInputValues(id, 'position', axis, value);
            }
        }
        
        function updateVideoRotation(id, value) {
            const videoObj = videoObjects.find(v => v.id === id);
            if (videoObj) {
                videoObj.mesh.rotation.z = THREE.MathUtils.degToRad(parseFloat(value));
                syncInputValues(id, 'rotation', null, value);
            }
        }
        
        function updateVideoScale(id, value) {
            const videoObj = videoObjects.find(v => v.id === id);
            if (videoObj) {
                const scale = parseFloat(value);
                videoObj.mesh.scale.set(scale, scale, scale);
                syncInputValues(id, 'scale', null, value);
            }
        }
        
        function updateVideoOpacity(id, value) {
            const videoObj = videoObjects.find(v => v.id === id);
            if (videoObj) {
                videoObj.material.opacity = parseFloat(value);
                syncInputValues(id, 'opacity', null, value);
            }
        }
        
        function syncInputValues(id, type, axis, value) {
            const container = document.getElementById(id);
            if (!container) return;
            
            let inputs;
            if (type === 'position' && axis) {
                const labels = container.querySelectorAll('label');
                labels.forEach(label => {
                    if (label.textContent === axis.toUpperCase() + ':') {
                        const group = label.parentElement;
                        inputs = group.querySelectorAll('input');
                        inputs.forEach(input => input.value = value);
                    }
                });
            } else {
                const allInputs = container.querySelectorAll('input');
                allInputs.forEach(input => {
                    if (input.oninput && input.oninput.toString().includes(type)) {
                        input.value = value;
                    }
                });
            }
        }
        
        function removeVideo(id) {
            const index = videoObjects.findIndex(v => v.id === id);
            if (index === -1) return;
            
            const videoObj = videoObjects[index];
            
            // 清理 Three.js 對象
            scene.remove(videoObj.mesh);
            videoObj.texture.dispose();
            videoObj.material.dispose();
            videoObj.mesh.geometry.dispose();
            
            // 停止視頻
            videoObj.element.pause();
            videoObj.element.src = '';
            
            // 移除 DOM
            document.getElementById(id).remove();
            
            // 從數組中移除
            videoObjects.splice(index, 1);
            
            updateStatus(`已移除: ${videoObj.name}`);
        }
        
        function resetAllPositions() {
            videoObjects.forEach((videoObj, index) => {
                videoObj.mesh.position.x = (index % 3 - 1) * 2.5;
                videoObj.mesh.position.y = Math.floor(index / 3) * 2 - 1;
                videoObj.mesh.position.z = 0;
                videoObj.mesh.rotation.set(0, 0, 0);
                videoObj.mesh.scale.set(1, 1, 1);
                videoObj.material.opacity = 1;
                
                // 更新控制
                updateAllControls(videoObj);
            });
            updateStatus('已重置所有視頻位置');
        }
        
        function arrangeInCircle() {
            const radius = 3;
            const count = videoObjects.length;
            
            videoObjects.forEach((videoObj, index) => {
                const angle = (index / count) * Math.PI * 2;
                videoObj.mesh.position.x = Math.cos(angle) * radius;
                videoObj.mesh.position.y = 0;
                videoObj.mesh.position.z = Math.sin(angle) * radius;
                videoObj.mesh.lookAt(0, 0, 0);
                
                updateAllControls(videoObj);
            });
            updateStatus('已排列為圓形');
        }
        
        function arrangeInGrid() {
            const cols = Math.ceil(Math.sqrt(videoObjects.length));
            const spacing = 2.5;
            
            videoObjects.forEach((videoObj, index) => {
                const x = (index % cols) - (cols - 1) / 2;
                const y = Math.floor(index / cols) - Math.floor(videoObjects.length / cols) / 2;
                
                videoObj.mesh.position.x = x * spacing;
                videoObj.mesh.position.y = y * spacing;
                videoObj.mesh.position.z = 0;
                videoObj.mesh.rotation.set(0, 0, 0);
                
                updateAllControls(videoObj);
            });
            updateStatus('已排列為網格');
        }
        
        function updateAllControls(videoObj) {
            updateVideoPosition(videoObj.id, 'x', videoObj.mesh.position.x);
            updateVideoPosition(videoObj.id, 'y', videoObj.mesh.position.y);
            updateVideoPosition(videoObj.id, 'z', videoObj.mesh.position.z);
            updateVideoRotation(videoObj.id, THREE.MathUtils.radToDeg(videoObj.mesh.rotation.z));
            updateVideoScale(videoObj.id, videoObj.mesh.scale.x);
            updateVideoOpacity(videoObj.id, videoObj.material.opacity);
        }
        
        // UI 控制
        function toggleControlPanel() {
            const controls = document.getElementById('controls');
            controls.classList.toggle('collapsed');
            const btn = controls.querySelector('.collapse-btn');
            btn.textContent = controls.classList.contains('collapsed') ? '展開' : '收起';
        }
        
        function updateStatus(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            
            // 3秒後恢復
            clearTimeout(status.timeout);
            status.timeout = setTimeout(() => {
                status.textContent = '準備就緒';
            }, 3000);
        }
        
        // 渲染循環
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // 更新視頻紋理
            videoObjects.forEach(videoObj => {
                if (videoObj.element.readyState >= videoObj.element.HAVE_CURRENT_DATA) {
                    videoObj.texture.needsUpdate = true;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // 初始化
        window.addEventListener('load', () => {
            initThreeJS();
            updateStatus('應用程式已就緒，請開啟攝像頭並載入視頻');
        });
        
        // 清理資源
        window.addEventListener('beforeunload', () => {
            stopCamera();
            videoObjects.forEach(videoObj => {
                videoObj.element.pause();
                videoObj.element.src = '';
            });
        });