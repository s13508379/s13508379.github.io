<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D PNG Layer Animator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            color: white;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="file"] {
            width: 100%;
            margin-bottom: 10px;
        }

        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        select {
            width: 100%;
            padding: 5px;
            border: 1px solid #333;
            background: #222;
            color: white;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }

        button:hover {
            background: #45a049;
        }

        button.danger {
            background: #f44336;
        }

        button.danger:hover {
            background: #da190b;
        }

        #layersList {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #333;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
        }

        .layer-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .layer-item.selected {
            background: rgba(76, 175, 80, 0.3);
        }

        .layer-item .delete-btn {
            position: absolute;
            right: 5px;
            top: 2px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
        }

        .animation-controls {
            border: 1px solid #333;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="controls">
            <h3>3D PNG Layer Animator</h3>

            <div class="control-group">
                <label>Project Name:</label>
                <input type="text" id="projectName" placeholder="Enter project name" value="project">
            </div>


            <div class="control-group">
                <label>Background Color:</label>
                <input type="color" id="bgColor" value="#000000" onchange="updateBackgroundColor()">
            </div>

            <div class="control-group">
                <label>Add PNG Image:</label>
                <input type="file" id="imageFile" accept="image/png,image/jpg,image/jpeg" multiple>
                <button onclick="addImageLayer()">Add Layer</button>
            </div>

            <div class="control-group">
                <label>Position X: <span id="xValue">0</span></label>
                <input type="range" id="xPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

                <label>Position Y: <span id="yValue">0</span></label>
                <input type="range" id="yPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

                <label>Position Z (Depth): <span id="zValue">0</span></label>
                <input type="range" id="zPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">
            </div>

            <div class="control-group">
                <label>Transparency: <span id="alphaValue">1.0</span></label>
                <input type="range" id="alpha" min="0" max="1" step="0.1" value="1" oninput="updateTransparency()">

                <label>Scale: <span id="scaleValue">1.0</span></label>
                <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1" oninput="updateScale()">
            </div>

            <div class="control-group">
                <label>Rotation X: <span id="rotXValue">0</span></label>
                <input type="range" id="rotX" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

                <label>Rotation Y: <span id="rotYValue">0</span></label>
                <input type="range" id="rotY" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

                <label>Rotation Z: <span id="rotZValue">0</span></label>
                <input type="range" id="rotZ" min="-180" max="180" step="1" value="0" oninput="updateRotation()">
            </div>

            <div class="animation-controls">
                <h4>Animation Controls</h4>
                <div class="control-group">
                    <label>Animation Type:</label>
                    <select id="animationType">
                        <option value="none">None</option>
                        <option value="custom">Custom Movement</option>
                        <option value="slideDown">Slide Down</option>
                        <option value="slideUp">Slide Up</option>
                        <option value="slideLeft">Slide Left</option>
                        <option value="slideRight">Slide Right</option>
                        <option value="fadeIn">Fade In</option>
                        <option value="scaleIn">Scale In</option>
                        <option value="rotate">Rotate</option>
                        <option value="bounce">Bounce</option>
                        <option value="spiral">Spiral</option>
                    </select>
                </div>

                <div class="control-group" id="customAnimationControls" style="display: none;">
                    <h5>Start Position:</h5>
                    <label>Start X: <span id="startXValue">0</span></label>
                    <input type="range" id="startX" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>Start Y: <span id="startYValue">0</span></label>
                    <input type="range" id="startY" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>Start Z: <span id="startZValue">0</span></label>
                    <input type="range" id="startZ" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">

                    <h5>End Position:</h5>
                    <label>End X: <span id="endXValue">0</span></label>
                    <input type="range" id="endX" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>End Y: <span id="endYValue">0</span></label>
                    <input type="range" id="endY" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>End Z: <span id="endZValue">0</span></label>
                    <input type="range" id="endZ" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">

                    <h5>Start Properties:</h5>
                    <label>Start Scale: <span id="startScaleValue">1.0</span></label>
                    <input type="range" id="startScale" min="0.1" max="5" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>Start Opacity: <span id="startOpacityValue">1.0</span></label>
                    <input type="range" id="startOpacity" min="0" max="1" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>Start Rotation: <span id="startRotationValue">0</span>°</label>
                    <input type="range" id="startRotation" min="-360" max="360" step="1" value="0"
                        oninput="updateCustomValues()">

                    <h5>End Properties:</h5>
                    <label>End Scale: <span id="endScaleValue">1.0</span></label>
                    <input type="range" id="endScale" min="0.1" max="5" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>End Opacity: <span id="endOpacityValue">1.0</span></label>
                    <input type="range" id="endOpacity" min="0" max="1" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>End Rotation: <span id="endRotationValue">0</span>°</label>
                    <input type="range" id="endRotation" min="-360" max="360" step="1" value="0"
                        oninput="updateCustomValues()">

                    <div class="control-group">
                        <button onclick="setCurrentAsStart()">Set Current as Start</button>
                        <button onclick="setCurrentAsEnd()">Set Current as End</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Animation Speed: <span id="speedValue">1.0</span></label>
                    <input type="range" id="animationSpeed" min="0.1" max="3" step="0.1" value="1"
                        oninput="updateAnimationSpeed()">
                </div>

                <div class="control-group">
                    <label>Animation Duration: <span id="durationValue">2.0</span>s</label>
                    <input type="range" id="animationDuration" min="0.5" max="5" step="0.1" value="2"
                        oninput="updateAnimationDuration()">
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="loopAnimation"> Loop Animation
                    </label>
                </div>

                <div class="control-group">
                    <button onclick="applyAnimation()">Apply Animation</button>
                    <button onclick="stopAnimation()">Stop Animation</button>
                    <button onclick="previewAnimation()">Preview Animation</button>
                </div>
            </div>

            <div class="control-group">
                <button onclick="resetCamera()">Reset Camera</button>
                <button onclick="playAllAnimations()">Play All Animations</button>
                <button onclick="stopAllAnimations()">Stop All Animations</button>
            </div>

            <div class="control-group">
                <h4>Export Options</h4>
                <button onclick="exportAsAR()">Export as AR.js</button>
            </div>

            <div id="layersList">
                <h4>Layers:</h4>
                <div id="layers"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- your main script here -->
    <script>
        let scene, camera, renderer;
        let imageLayers = [];
        let selectedLayer = null;
        let layerCounter = 0;
        let animationMixer;
        let clock;

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize animation system
            clock = new THREE.Clock();

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Add grid helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
            scene.add(gridHelper);

            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Mouse controls
            addMouseControls();

            animate();
        }

        // Add mouse controls for camera
        function addMouseControls() {
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(1, 50);
            });
        }

        // Update background color
        function updateBackgroundColor() {
            const color = document.getElementById('bgColor').value;
            scene.background = new THREE.Color(color);
        }

        // Add image layer
        function addImageLayer() {
            const fileInput = document.getElementById('imageFile');
            const files = fileInput.files;

            if (files.length === 0) {
                alert('Please select image files first');
                return;
            }

            Array.from(files).forEach(file => {
                const img = new Image();
                img.onload = function () {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;

                    // Calculate aspect ratio
                    const aspect = img.width / img.height;
                    const geometry = new THREE.PlaneGeometry(2 * aspect, 2);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide,
                        alphaTest: 0.1
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(0, 0, 0);

                    const layer = {
                        id: layerCounter++,
                        name: file.name,
                        mesh: mesh,
                        texture: texture,
                        originalPosition: { x: 0, y: 0, z: 0 },
                        originalRotation: { x: 0, y: 0, z: 0 },
                        originalScale: { x: 1, y: 1, z: 1 },
                        originalOpacity: 1,
                        animation: null,
                        animationType: 'none',
                        animationSpeed: 1,
                        animationDuration: 2,
                        customAnimation: {
                            start: { x: 0, y: 0, z: 0, scale: 1, opacity: 1, rotation: 0 },
                            end: { x: 0, y: 0, z: 0, scale: 1, opacity: 1, rotation: 0 }
                        }
                    };

                    imageLayers.push(layer);
                    scene.add(mesh);

                    updateLayersList();
                    selectLayer(layer);
                };
                img.src = URL.createObjectURL(file);
            });

            fileInput.value = '';
        }

        // Update layers list
        function updateLayersList() {
            const layersDiv = document.getElementById('layers');
            layersDiv.innerHTML = '';

            imageLayers.forEach(layer => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-item';
                layerDiv.innerHTML = `
                    <span>${layer.id}: ${layer.name}</span>
                    <button class="delete-btn" onclick="deleteLayer(${layer.id})">×</button>
                `;
                layerDiv.onclick = (e) => {
                    if (e.target.classList.contains('delete-btn')) return;
                    selectLayer(layer);
                };
                layersDiv.appendChild(layerDiv);
            });
        }

        // Delete layer
        function deleteLayer(layerId) {
            const layerIndex = imageLayers.findIndex(layer => layer.id === layerId);
            if (layerIndex === -1) return;

            const layer = imageLayers[layerIndex];
            scene.remove(layer.mesh);
            imageLayers.splice(layerIndex, 1);

            if (selectedLayer && selectedLayer.id === layerId) {
                selectedLayer = null;
            }

            updateLayersList();
        }

        // Select layer
        function selectLayer(layer) {
            selectedLayer = layer;

            // Update UI
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('selected');
            });

            const layerItems = document.querySelectorAll('.layer-item');
            if (layerItems[imageLayers.indexOf(layer)]) {
                layerItems[imageLayers.indexOf(layer)].classList.add('selected');
            }

            // Update controls to match selected layer
            const pos = layer.mesh.position;
            const rot = layer.mesh.rotation;
            const scale = layer.mesh.scale.x;
            const alpha = layer.mesh.material.opacity;

            document.getElementById('xPos').value = pos.x;
            document.getElementById('yPos').value = pos.y;
            document.getElementById('zPos').value = pos.z;
            document.getElementById('rotX').value = rot.x * 180 / Math.PI;
            document.getElementById('rotY').value = rot.y * 180 / Math.PI;
            document.getElementById('rotZ').value = rot.z * 180 / Math.PI;
            document.getElementById('scale').value = scale;
            document.getElementById('alpha').value = alpha;
            document.getElementById('animationType').value = layer.animationType;
            document.getElementById('animationSpeed').value = layer.animationSpeed;
            document.getElementById('animationDuration').value = layer.animationDuration;

            // Update custom animation controls
            const custom = layer.customAnimation;
            document.getElementById('startX').value = custom.start.x;
            document.getElementById('startY').value = custom.start.y;
            document.getElementById('startZ').value = custom.start.z;
            document.getElementById('startScale').value = custom.start.scale;
            document.getElementById('startOpacity').value = custom.start.opacity;
            document.getElementById('startRotation').value = custom.start.rotation;

            document.getElementById('endX').value = custom.end.x;
            document.getElementById('endY').value = custom.end.y;
            document.getElementById('endZ').value = custom.end.z;
            document.getElementById('endScale').value = custom.end.scale;
            document.getElementById('endOpacity').value = custom.end.opacity;
            document.getElementById('endRotation').value = custom.end.rotation;

            // Show/hide custom animation controls
            const customControls = document.getElementById('customAnimationControls');
            customControls.style.display = layer.animationType === 'custom' ? 'block' : 'none';

            updateControlValues();
        }

        // Update control value displays
        function updateControlValues() {
            document.getElementById('xValue').textContent = document.getElementById('xPos').value;
            document.getElementById('yValue').textContent = document.getElementById('yPos').value;
            document.getElementById('zValue').textContent = document.getElementById('zPos').value;
            document.getElementById('rotXValue').textContent = document.getElementById('rotX').value + '°';
            document.getElementById('rotYValue').textContent = document.getElementById('rotY').value + '°';
            document.getElementById('rotZValue').textContent = document.getElementById('rotZ').value + '°';
            document.getElementById('scaleValue').textContent = document.getElementById('scale').value;
            document.getElementById('alphaValue').textContent = document.getElementById('alpha').value;
            document.getElementById('speedValue').textContent = document.getElementById('animationSpeed').value;
            document.getElementById('durationValue').textContent = document.getElementById('animationDuration').value;

            // Update custom animation values
            updateCustomValues();
        }

        // Update custom animation values
        function updateCustomValues() {
            document.getElementById('startXValue').textContent = document.getElementById('startX').value;
            document.getElementById('startYValue').textContent = document.getElementById('startY').value;
            document.getElementById('startZValue').textContent = document.getElementById('startZ').value;
            document.getElementById('startScaleValue').textContent = document.getElementById('startScale').value;
            document.getElementById('startOpacityValue').textContent = document.getElementById('startOpacity').value;
            document.getElementById('startRotationValue').textContent = document.getElementById('startRotation').value;

            document.getElementById('endXValue').textContent = document.getElementById('endX').value;
            document.getElementById('endYValue').textContent = document.getElementById('endY').value;
            document.getElementById('endZValue').textContent = document.getElementById('endZ').value;
            document.getElementById('endScaleValue').textContent = document.getElementById('endScale').value;
            document.getElementById('endOpacityValue').textContent = document.getElementById('endOpacity').value;
            document.getElementById('endRotationValue').textContent = document.getElementById('endRotation').value;

            // Update selected layer's custom animation data
            if (selectedLayer) {
                selectedLayer.customAnimation = {
                    start: {
                        x: parseFloat(document.getElementById('startX').value),
                        y: parseFloat(document.getElementById('startY').value),
                        z: parseFloat(document.getElementById('startZ').value),
                        scale: parseFloat(document.getElementById('startScale').value),
                        opacity: parseFloat(document.getElementById('startOpacity').value),
                        rotation: parseFloat(document.getElementById('startRotation').value)
                    },
                    end: {
                        x: parseFloat(document.getElementById('endX').value),
                        y: parseFloat(document.getElementById('endY').value),
                        z: parseFloat(document.getElementById('endZ').value),
                        scale: parseFloat(document.getElementById('endScale').value),
                        opacity: parseFloat(document.getElementById('endOpacity').value),
                        rotation: parseFloat(document.getElementById('endRotation').value)
                    }
                };
            }
        }

        // Set current position/properties as start
        function setCurrentAsStart() {
            if (!selectedLayer) return;

            const mesh = selectedLayer.mesh;
            document.getElementById('startX').value = mesh.position.x;
            document.getElementById('startY').value = mesh.position.y;
            document.getElementById('startZ').value = mesh.position.z;
            document.getElementById('startScale').value = mesh.scale.x;
            document.getElementById('startOpacity').value = mesh.material.opacity;
            document.getElementById('startRotation').value = mesh.rotation.z * 180 / Math.PI;

            updateCustomValues();
        }

        // Set current position/properties as end
        function setCurrentAsEnd() {
            if (!selectedLayer) return;

            const mesh = selectedLayer.mesh;
            document.getElementById('endX').value = mesh.position.x;
            document.getElementById('endY').value = mesh.position.y;
            document.getElementById('endZ').value = mesh.position.z;
            document.getElementById('endScale').value = mesh.scale.x;
            document.getElementById('endOpacity').value = mesh.material.opacity;
            document.getElementById('endRotation').value = mesh.rotation.z * 180 / Math.PI;

            updateCustomValues();
        }

        // Update position
        function updatePosition() {
            if (!selectedLayer) return;

            const x = parseFloat(document.getElementById('xPos').value);
            const y = parseFloat(document.getElementById('yPos').value);
            const z = parseFloat(document.getElementById('zPos').value);

            selectedLayer.mesh.position.set(x, y, z);
            selectedLayer.originalPosition = { x, y, z };
            updateControlValues();
        }

        // Update rotation
        function updateRotation() {
            if (!selectedLayer) return;

            const x = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
            const y = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
            const z = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;

            selectedLayer.mesh.rotation.set(x, y, z);
            selectedLayer.originalRotation = { x, y, z };
            updateControlValues();
        }

        // Update transparency
        function updateTransparency() {
            if (!selectedLayer) return;

            const alpha = parseFloat(document.getElementById('alpha').value);
            selectedLayer.mesh.material.opacity = alpha;
            selectedLayer.originalOpacity = alpha;
            updateControlValues();
        }

        // Update scale
        function updateScale() {
            if (!selectedLayer) return;

            const scale = parseFloat(document.getElementById('scale').value);
            selectedLayer.mesh.scale.set(scale, scale, scale);
            selectedLayer.originalScale = { x: scale, y: scale, z: scale };
            updateControlValues();
        }

        // Update animation speed
        function updateAnimationSpeed() {
            if (!selectedLayer) return;
            selectedLayer.animationSpeed = parseFloat(document.getElementById('animationSpeed').value);
            updateControlValues();
        }

        // Update animation duration
        function updateAnimationDuration() {
            if (!selectedLayer) return;
            selectedLayer.animationDuration = parseFloat(document.getElementById('animationDuration').value);
            updateControlValues();
        }

        // Apply animation
        function applyAnimation() {
            if (!selectedLayer) return;

            const animationType = document.getElementById('animationType').value;
            selectedLayer.animationType = animationType;

            // Show/hide custom animation controls
            const customControls = document.getElementById('customAnimationControls');
            customControls.style.display = animationType === 'custom' ? 'block' : 'none';

            if (animationType === 'none') {
                stopAnimation();
                return;
            }

            const mesh = selectedLayer.mesh;
            const duration = selectedLayer.animationDuration;
            const speed = selectedLayer.animationSpeed;
            const loop = document.getElementById('loopAnimation').checked;

            // Stop existing animation
            if (selectedLayer.animation) {
                selectedLayer.animation.stop();
            }

            // Create animation based on type
            const startTime = Date.now();
            selectedLayer.animation = {
                stop: () => { selectedLayer.animation = null; },
                update: (currentTime) => {
                    const elapsed = (currentTime - startTime) / 1000 * speed;
                    let progress = (elapsed % duration) / duration;

                    if (!loop && elapsed > duration) {
                        progress = 1;
                    }

                    // Smooth easing function
                    const easeInOut = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    const easedProgress = easeInOut(progress);

                    if (animationType === 'custom') {
                        const start = selectedLayer.customAnimation.start;
                        const end = selectedLayer.customAnimation.end;

                        // Interpolate position
                        mesh.position.x = start.x + (end.x - start.x) * easedProgress;
                        mesh.position.y = start.y + (end.y - start.y) * easedProgress;
                        mesh.position.z = start.z + (end.z - start.z) * easedProgress;

                        // Interpolate scale
                        const scale = start.scale + (end.scale - start.scale) * easedProgress;
                        mesh.scale.set(scale, scale, scale);

                        // Interpolate opacity
                        mesh.material.opacity = start.opacity + (end.opacity - start.opacity) * easedProgress;

                        // Interpolate rotation
                        const rotation = (start.rotation + (end.rotation - start.rotation) * easedProgress) * Math.PI / 180;
                        mesh.rotation.z = rotation;

                    } else {
                        // Reset to original state first
                        mesh.position.copy(selectedLayer.originalPosition);
                        mesh.rotation.copy(selectedLayer.originalRotation);
                        mesh.scale.copy(selectedLayer.originalScale);
                        mesh.material.opacity = selectedLayer.originalOpacity;

                        // Apply preset animations
                        switch (animationType) {
                            case 'slideDown':
                                mesh.position.y = selectedLayer.originalPosition.y + 10 * (1 - easedProgress);
                                break;
                            case 'slideUp':
                                mesh.position.y = selectedLayer.originalPosition.y - 10 * (1 - easedProgress);
                                break;
                            case 'slideLeft':
                                mesh.position.x = selectedLayer.originalPosition.x + 10 * (1 - easedProgress);
                                break;
                            case 'slideRight':
                                mesh.position.x = selectedLayer.originalPosition.x - 10 * (1 - easedProgress);
                                break;
                            case 'fadeIn':
                                mesh.material.opacity = selectedLayer.originalOpacity * easedProgress;
                                break;
                            case 'scaleIn':
                                const scale = selectedLayer.originalScale.x * easedProgress;
                                mesh.scale.set(scale, scale, scale);
                                break;
                            case 'rotate':
                                mesh.rotation.z = selectedLayer.originalRotation.z + easedProgress * Math.PI * 2;
                                break;
                            case 'bounce':
                                const bounceY = Math.abs(Math.sin(easedProgress * Math.PI * 4)) * 2;
                                mesh.position.y = selectedLayer.originalPosition.y + bounceY;
                                break;
                            case 'spiral':
                                const spiralRadius = 3 * (1 - easedProgress);
                                const spiralAngle = easedProgress * Math.PI * 6;
                                mesh.position.x = selectedLayer.originalPosition.x + spiralRadius * Math.cos(spiralAngle);
                                mesh.position.y = selectedLayer.originalPosition.y + spiralRadius * Math.sin(spiralAngle);
                                break;
                        }
                    }
                }
            };
        }

        // Preview animation (single run)
        function previewAnimation() {
            if (!selectedLayer) return;

            const originalLoop = document.getElementById('loopAnimation').checked;
            document.getElementById('loopAnimation').checked = false;

            applyAnimation();

            // Restore original loop setting after animation
            setTimeout(() => {
                document.getElementById('loopAnimation').checked = originalLoop;
            }, selectedLayer.animationDuration * 1000);
        }

        // Stop animation for selected layer
        function stopAnimation() {
            if (!selectedLayer || !selectedLayer.animation) return;

            selectedLayer.animation.stop();
            selectedLayer.animationType = 'none';
            document.getElementById('animationType').value = 'none';

            // Reset to original state
            const mesh = selectedLayer.mesh;
            mesh.position.copy(selectedLayer.originalPosition);
            mesh.rotation.copy(selectedLayer.originalRotation);
            mesh.scale.copy(selectedLayer.originalScale);
            mesh.material.opacity = selectedLayer.originalOpacity;
        }

        // Play all animations
        function playAllAnimations() {
            imageLayers.forEach(layer => {
                if (layer.animationType !== 'none') {
                    selectLayer(layer);
                    applyAnimation();
                }
            });
        }

        // Stop all animations
        function stopAllAnimations() {
            imageLayers.forEach(layer => {
                if (layer.animation) {
                    layer.animation.stop();
                }
                layer.animationType = 'none';

                // Reset to original state
                const mesh = layer.mesh;
                mesh.position.copy(layer.originalPosition);
                mesh.rotation.copy(layer.originalRotation);
                mesh.scale.copy(layer.originalScale);
                mesh.material.opacity = layer.originalOpacity;
            });
        }

        // Reset camera
        function resetCamera() {
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();

            // Update animations
            imageLayers.forEach(layer => {
                if (layer.animation && layer.animation.update) {
                    layer.animation.update(currentTime);
                }
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize scene when page loads
        window.addEventListener('load', initScene);

        function exportAsAR() {
            const projectName = document.getElementById('projectName').value || 'project';
            const backgroundColor = document.getElementById('bgColor').value;

            const layersData = imageLayers.map(layer => ({
                id: layer.id,
                name: layer.name,
                position: {
                    x: layer.mesh.position.x,
                    y: layer.mesh.position.y,
                    z: layer.mesh.position.z
                },
                rotation: {
                    x: layer.mesh.rotation.x,
                    y: layer.mesh.rotation.y,
                    z: layer.mesh.rotation.z
                },
                scale: {
                    x: layer.mesh.scale.x,
                    y: layer.mesh.scale.y,
                    z: layer.mesh.scale.z
                },
                opacity: layer.mesh.material.opacity,
                animationType: layer.animationType,
                animationSpeed: layer.animationSpeed,
                animationDuration: layer.animationDuration,
                customAnimation: layer.customAnimation,
                imageData: getImageDataURL(layer.texture.image)
            }));

            const arHtmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${projectName} - AR Experience</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #arScene {
            width: 100%;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>${projectName} AR</h3>
        <div class="control-group">
            <button onclick="playAllAnimations()">Play All</button>
            <button onclick="stopAllAnimations()">Stop All</button>
        </div>
        <div class="control-group">
            <label>AR Scale: <span id="arScaleValue">1.0</span></label>
            <input type="range" id="arScale" min="0.1" max="5" step="0.1" value="1" oninput="updateARScale()">
        </div>
        <div class="control-group">
            <label>AR Height: <span id="arHeightValue">0</span></label>
            <input type="range" id="arHeight" min="-2" max="2" step="0.1" value="0" oninput="updateARHeight()">
        </div>
        <div class="control-group">
            <button onclick="toggleControls()">Hide Controls</button>
        </div>
    </div>
    
    <div id="info">
        Point camera at marker to see AR content
    </div>

    <a-scene
        id="arScene"
        embedded
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; precision: medium;"
        loading-screen="enabled: false"
        gesture-detector
    >
        <a-assets>
            <!-- Marker Assets -->
            <a-marker-camera id="marker" preset="hiro" raycaster="objects: .clickable" emitevents="true" cursor="fuse: false; rayOrigin: mouse">
                <a-entity id="arContainer" position="0 0 0" scale="1 1 1">
                    <!-- 3D content will be added here -->
                </a-entity>
            </a-marker-camera>
        </a-assets>

        <a-entity camera></a-entity>
    </a-scene>

    <!-- AR.js -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"><\/script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"><\/script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"><\/script>
    
    <script>
        let arContainer;
        let arLayers = [];
        let arScale = 1;
        let arHeight = 0;
        let controlsVisible = true;

        const layersData = ${JSON.stringify(layersData)};

        // Initialize AR scene
        AFRAME.registerComponent('ar-init', {
            init: function() {
                arContainer = document.getElementById('arContainer');
                loadARLayers();
            }
        });

        // Add the component to the scene
        document.querySelector('a-scene').setAttribute('ar-init', '');

        function loadARLayers() {
            layersData.forEach((layerData, index) => {
                // Create image element
                const imgEl = document.createElement('img');
                imgEl.src = layerData.imageData;
                imgEl.id = 'img-' + layerData.id;
                imgEl.crossOrigin = 'anonymous';
                
                // Add to assets
                const assets = document.querySelector('a-assets');
                assets.appendChild(imgEl);

                imgEl.onload = function() {
                    // Calculate aspect ratio
                    const aspect = imgEl.width / imgEl.height;
                    
                    // Create A-Frame plane
                    const plane = document.createElement('a-plane');
                    plane.setAttribute('id', 'layer-' + layerData.id);
                    plane.setAttribute('src', '#img-' + layerData.id);
                    plane.setAttribute('width', 2 * aspect);
                    plane.setAttribute('height', 2);
                    plane.setAttribute('position', 
                        layerData.position.x + ' ' + 
                        layerData.position.y + ' ' + 
                        layerData.position.z
                    );
                    plane.setAttribute('rotation', 
                        (layerData.rotation.x * 180 / Math.PI) + ' ' + 
                        (layerData.rotation.y * 180 / Math.PI) + ' ' + 
                        (layerData.rotation.z * 180 / Math.PI)
                    );
                    plane.setAttribute('scale', 
                        layerData.scale.x + ' ' + 
                        layerData.scale.y + ' ' + 
                        layerData.scale.z
                    );
                    plane.setAttribute('opacity', layerData.opacity);
                    plane.setAttribute('transparent', 'true');
                    plane.setAttribute('material', 'alphaTest: 0.1');
                    
                    // Store layer data
                    plane.layerData = layerData;
                    
                    // Add to AR container
                    arContainer.appendChild(plane);
                    arLayers.push(plane);
                    
                    // Start animation if needed
                    if (layerData.animationType !== 'none') {
                        startARAnimation(plane);
                    }
                };
            });
        }

        function startARAnimation(plane) {
            const layerData = plane.layerData;
            const animationType = layerData.animationType;
            const duration = layerData.animationDuration * 1000; // Convert to milliseconds
            
            if (animationType === 'custom') {
                const start = layerData.customAnimation.start;
                const end = layerData.customAnimation.end;
                
                // Position animation
                plane.setAttribute('animation__position', {
                    property: 'position',
                    from: start.x + ' ' + start.y + ' ' + start.z,
                    to: end.x + ' ' + end.y + ' ' + end.z,
                    dur: duration,
                    easing: 'easeInOutQuad',
                    loop: true
                });
                
                // Scale animation
                plane.setAttribute('animation__scale', {
                    property: 'scale',
                    from: start.scale + ' ' + start.scale + ' ' + start.scale,
                    to: end.scale + ' ' + end.scale + ' ' + end.scale,
                    dur: duration,
                    easing: 'easeInOutQuad',
                    loop: true
                });
                
                // Opacity animation
                plane.setAttribute('animation__opacity', {
                    property: 'opacity',
                    from: start.opacity,
                    to: end.opacity,
                    dur: duration,
                    easing: 'easeInOutQuad',
                    loop: true
                });
                
                // Rotation animation
                plane.setAttribute('animation__rotation', {
                    property: 'rotation',
                    from: start.rotation + ' 0 0',
                    to: end.rotation + ' 0 0',
                    dur: duration,
                    easing: 'easeInOutQuad',
                    loop: true
                });
            } else {
                // Preset animations
                const originalPos = layerData.position;
                switch (animationType) {
                    case 'slideDown':
                        plane.setAttribute('animation', {
                            property: 'position',
                            from: originalPos.x + ' ' + (originalPos.y + 10) + ' ' + originalPos.z,
                            to: originalPos.x + ' ' + originalPos.y + ' ' + originalPos.z,
                            dur: duration,
                            easing: 'easeInOutQuad',
                            loop: true
                        });
                        break;
                    case 'fadeIn':
                        plane.setAttribute('animation', {
                            property: 'opacity',
                            from: 0,
                            to: layerData.opacity,
                            dur: duration,
                            easing: 'easeInOutQuad',
                            loop: true
                        });
                        break;
                    case 'rotate':
                        plane.setAttribute('animation', {
                            property: 'rotation',
                            from: '0 0 0',
                            to: '0 0 360',
                            dur: duration,
                            easing: 'linear',
                            loop: true
                        });
                        break;
                    case 'bounce':
                        plane.setAttribute('animation', {
                            property: 'position',
                            from: originalPos.x + ' ' + originalPos.y + ' ' + originalPos.z,
                            to: originalPos.x + ' ' + (originalPos.y + 2) + ' ' + originalPos.z,
                            dur: duration / 2,
                            easing: 'easeInOutQuad',
                            loop: true,
                            dir: 'alternate'
                        });
                        break;
                }
            }
        }

        function playAllAnimations() {
            arLayers.forEach(layer => {
                if (layer.layerData.animationType !== 'none') {
                    startARAnimation(layer);
                }
            });
        }

        function stopAllAnimations() {
            arLayers.forEach(layer => {
                layer.removeAttribute('animation');
                layer.removeAttribute('animation__position');
                layer.removeAttribute('animation__scale');
                layer.removeAttribute('animation__opacity');
                layer.removeAttribute('animation__rotation');
            });
        }

        function updateARScale() {
            arScale = parseFloat(document.getElementById('arScale').value);
            document.getElementById('arScaleValue').textContent = arScale.toFixed(1);
            arContainer.setAttribute('scale', arScale + ' ' + arScale + ' ' + arScale);
        }

        function updateARHeight() {
            arHeight = parseFloat(document.getElementById('arHeight').value);
            document.getElementById('arHeightValue').textContent = arHeight.toFixed(1);
            const currentPos = arContainer.getAttribute('position');
            arContainer.setAttribute('position', currentPos.x + ' ' + arHeight + ' ' + currentPos.z);
        }

        function toggleControls() {
            const controls = document.getElementById('controls');
            const button = controls.querySelector('button:last-child');
            if (controlsVisible) {
                controls.style.display = 'none';
                controlsVisible = false;
                
                // Create floating toggle button
                const toggleBtn = document.createElement('button');
                toggleBtn.innerHTML = 'Show Controls';
                toggleBtn.style.position = 'absolute';
                toggleBtn.style.top = '10px';
                toggleBtn.style.left = '10px';
                toggleBtn.style.zIndex = '1001';
                toggleBtn.onclick = () => {
                    controls.style.display = 'block';
                    controlsVisible = true;
                    document.body.removeChild(toggleBtn);
                };
                document.body.appendChild(toggleBtn);
            } else {
                controls.style.display = 'block';
                controlsVisible = true;
            }
        }

        // Update control values on load
        document.getElementById('arScaleValue').textContent = '1.0';
        document.getElementById('arHeightValue').textContent = '0.0';
    <\/script>
</body>
</html>`;

            const blob = new Blob([arHtmlContent], { type: 'text/html' });
            saveAs(blob, `${projectName}_AR.html`);
        }

    </script>
</body>

</html>