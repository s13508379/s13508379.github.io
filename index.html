<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D PNG Layer Animator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #222;
            color: #fff;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            z-index: 100;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        .control-group input[type="text"],
        .control-group input[type="color"],
        .control-group select {
            width: 100%;
            padding: 5px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            border-radius: 3px;
        }

        .control-group button {
            padding: 8px 15px;
            margin: 2px;
            border: none;
            background: #0066cc;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .control-group button:hover {
            background: #0052a3;
        }

        .layer-item {
            padding: 8px;
            margin: 5px 0;
            background: #333;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid transparent;
        }

        .layer-item.selected {
            border-color: #0066cc;
            background: #444;
        }

        .delete-btn {
            background: #cc0000 !important;
            color: white;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
        }

        .delete-btn:hover {
            background: #aa0000 !important;
        }

        .animation-controls {
            border-top: 1px solid #555;
            padding-top: 15px;
            margin-top: 15px;
        }

        h3,
        h4,
        h5 {
            margin: 0 0 10px 0;
            color: #fff;
        }

        .audio-preview {
            max-width: 100%;
            margin-top: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="controls">
            <h3>3D PNG Layer Animator</h3>

            <div class="control-group">
                <label>Project Name:</label>
                <input type="text" id="projectName" placeholder="Enter project name" value="project">
            </div>

            <div class="control-group">
                <label>Website URL (for QR Code):</label>
                <input type="url" id="websiteUrl" placeholder="https://your-website.com" value="">
            </div>


            <div class="control-group">
                <label>Background Color:</label>
                <input type="color" id="bgColor" value="#000000" onchange="updateBackgroundColor()">
            </div>

            <div class="control-group">
                <label>Add MP3 Background Audio:</label>
                <input type="file" id="audioFile" accept="audio/mp3,audio/wav,audio/ogg">
                <button onclick="addAudioBackground()">Set Audio Background</button>
                <audio id="audioPreview" class="audio-preview" style="display: none;" controls loop></audio>
            </div>

            <div class="control-group">
                <label>Add PNG Image:</label>
                <input type="file" id="imageFile" accept="image/png,image/jpg,image/jpeg" multiple>
                <button onclick="addImageLayer()">Add Layer</button>
            </div>

            <div class="control-group">
                <label>Position X: <span id="xValue">0</span></label>
                <input type="range" id="xPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

                <label>Position Y: <span id="yValue">0</span></label>
                <input type="range" id="yPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">

                <label>Position Z (Depth): <span id="zValue">0</span></label>
                <input type="range" id="zPos" min="-10" max="10" step="0.1" value="0" oninput="updatePosition()">
            </div>

            <div class="control-group">
                <label>Transparency: <span id="alphaValue">1.0</span></label>
                <input type="range" id="alpha" min="0" max="1" step="0.1" value="1" oninput="updateTransparency()">

                <label>Scale: <span id="scaleValue">1.0</span></label>
                <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1" oninput="updateScale()">
            </div>

            <div class="control-group">
                <label>Rotation X: <span id="rotXValue">0</span></label>
                <input type="range" id="rotX" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

                <label>Rotation Y: <span id="rotYValue">0</span></label>
                <input type="range" id="rotY" min="-180" max="180" step="1" value="0" oninput="updateRotation()">

                <label>Rotation Z: <span id="rotZValue">0</span></label>
                <input type="range" id="rotZ" min="-180" max="180" step="1" value="0" oninput="updateRotation()">
            </div>

            <div class="animation-controls">
                <h4>Animation Controls</h4>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="enableCustomAnimation" onchange="toggleCustomControls()"> Enable
                        Custom Animation
                    </label>
                </div>

                <div class="control-group">
                    <label>Special Effect:</label>
                    <select id="specialEffect" onchange="updateSpecialEffect()">
                        <option value="none">None</option>
                        <option value="slideDown">Slide Down</option>
                        <option value="slideUp">Slide Up</option>
                        <option value="slideLeft">Slide Left</option>
                        <option value="slideRight">Slide Right</option>
                        <option value="fadeIn">Fade In</option>
                        <option value="scaleIn">Scale In</option>
                        <option value="rotate">Rotate</option>
                        <option value="bounce">Bounce</option>
                        <option value="spiral">Spiral</option>
                        <option value="swingToTarget">Swing to Target (90°↔0°)</option>
                        <option value="zigzagToTarget">Zigzag to Target (L↔R)</option>
                        <option value="pendulumMove">Pendulum Movement</option>
                        <option value="waveToTarget">Wave to Target</option>
                        <option value="elasticMove">Elastic Movement</option>
                    </select>
                </div>

                <div class="control-group" id="customAnimationControls" style="display: none;">
                    <h5>Custom Animation Settings</h5>

                    <h5>Start Position:</h5>
                    <label>Start X: <span id="startXValue">0</span></label>
                    <input type="range" id="startX" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>Start Y: <span id="startYValue">0</span></label>
                    <input type="range" id="startY" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>Start Z: <span id="startZValue">0</span></label>
                    <input type="range" id="startZ" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">

                    <h5>End Position:</h5>
                    <label>End X: <span id="endXValue">0</span></label>
                    <input type="range" id="endX" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>End Y: <span id="endYValue">0</span></label>
                    <input type="range" id="endY" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">
                    <label>End Z: <span id="endZValue">0</span></label>
                    <input type="range" id="endZ" min="-15" max="15" step="0.1" value="0"
                        oninput="updateCustomValues()">

                    <h5>Start Properties:</h5>
                    <label>Start Scale: <span id="startScaleValue">1.0</span></label>
                    <input type="range" id="startScale" min="0.1" max="5" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>Start Opacity: <span id="startOpacityValue">1.0</span></label>
                    <input type="range" id="startOpacity" min="0" max="1" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>Start Rotation: <span id="startRotationValue">0</span>°</label>
                    <input type="range" id="startRotation" min="-360" max="360" step="1" value="0"
                        oninput="updateCustomValues()">

                    <h5>End Properties:</h5>
                    <label>End Scale: <span id="endScaleValue">1.0</span></label>
                    <input type="range" id="endScale" min="0.1" max="5" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>End Opacity: <span id="endOpacityValue">1.0</span></label>
                    <input type="range" id="endOpacity" min="0" max="1" step="0.1" value="1"
                        oninput="updateCustomValues()">
                    <label>End Rotation: <span id="endRotationValue">0</span>°</label>
                    <input type="range" id="endRotation" min="-360" max="360" step="1" value="0"
                        oninput="updateCustomValues()">
                </div>

                <div class="control-group">
                    <label>Animation Speed: <span id="speedValue">1.0</span></label>
                    <input type="range" id="animationSpeed" min="0.1" max="3" step="0.1" value="1"
                        oninput="updateAnimationSpeed()">
                </div>

                <div class="control-group">
                    <label>Animation Duration: <span id="durationValue">2.0</span>s</label>
                    <input type="range" id="animationDuration" min="0.5" max="5" step="0.1" value="2"
                        oninput="updateAnimationDuration()">
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="loopAnimation"> Loop Animation
                    </label>
                </div>

                <div class="control-group">
                    <button onclick="applyAnimation()">Apply Animation</button>
                    <button onclick="stopAnimation()">Stop Animation</button>
                    <button onclick="previewAnimation()">Preview Animation</button>
                </div>
            </div>

            <div class="control-group">
                <button onclick="resetCamera()">Reset Camera</button>
                <button onclick="playAllAnimations()">Play All Animations</button>
                <button onclick="stopAllAnimations()">Stop All Animations</button>
            </div>

            <div class="control-group">
                <h4>Export Options</h4>
                <button onclick="exportAsAR()">Export as AR.js</button>
            </div>

            <div id="layersList">
                <h4>Layers:</h4>
                <div id="layers"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
    <script>
        let scene, camera, renderer;
        let imageLayers = [];
        let selectedLayer = null;
        let layerCounter = 0;
        let backgroundAudio = null;
        let clock;

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Add grid helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
            scene.add(gridHelper);

            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            addMouseControls();
            animate();
        }

        // Add mouse controls for camera
        function addMouseControls() {
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.clampLength(1, 50);
            });
        }

        function addAudioBackground() {
            const fileInput = document.getElementById('audioFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select an audio file first');
                return;
            }

            if (!file.type.startsWith('audio/')) {
                alert('Please select a valid audio file');
                return;
            }

            const audio = document.createElement('audio');
            const preview = document.getElementById('audioPreview');

            audio.src = URL.createObjectURL(file);
            preview.src = audio.src;
            preview.style.display = 'block';

            audio.loop = true;
            audio.volume = 0.5;

            // Store audio blob for export
            audioBlob = file;
            backgroundAudio = {
                element: audio,
                fileName: file.name,
                blob: file
            };

            fileInput.value = '';
        }

        // Update background color
        function updateBackgroundColor() {
            const color = document.getElementById('bgColor').value;
            scene.background = new THREE.Color(color);
        }

        // Add image layer
        function addImageLayer() {
            const fileInput = document.getElementById('imageFile');
            const files = fileInput.files;

            if (files.length === 0) {
                alert('Please select image files first');
                return;
            }

            Array.from(files).forEach(file => {
                const img = new Image();
                img.onload = function () {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;

                    const aspect = img.width / img.height;
                    const geometry = new THREE.PlaneGeometry(2 * aspect, 2);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide,
                        alphaTest: 0.1
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(0, 0, 0);

                    const layer = {
                        id: layerCounter++,
                        name: file.name,
                        mesh: mesh,
                        texture: texture,
                        originalPosition: { x: 0, y: 0, z: 0 },
                        originalRotation: { x: 0, y: 0, z: 0 },
                        originalScale: { x: 1, y: 1, z: 1 },
                        originalOpacity: 1,
                        animation: null,
                        enableCustomAnimation: false,
                        specialEffect: 'none',
                        animationSpeed: 1,
                        animationDuration: 2,
                        loopAnimation: false,
                        customAnimation: {
                            start: { x: 0, y: 0, z: 0, scale: 1, opacity: 1, rotation: 0 },
                            end: { x: 0, y: 0, z: 0, scale: 1, opacity: 1, rotation: 0 }
                        }
                    };

                    imageLayers.push(layer);
                    scene.add(mesh);

                    updateLayersList();
                    selectLayer(layer);
                };
                img.src = URL.createObjectURL(file);
            });

            fileInput.value = '';
        }

        // Update layers list
        function updateLayersList() {
            const layersDiv = document.getElementById('layers');
            layersDiv.innerHTML = '';

            imageLayers.forEach(layer => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-item';
                layerDiv.innerHTML = `
                    <span>${layer.id}: ${layer.name}</span>
                    <button class="delete-btn" onclick="deleteLayer(${layer.id})">×</button>
                `;
                layerDiv.onclick = (e) => {
                    if (e.target.classList.contains('delete-btn')) return;
                    selectLayer(layer);
                };
                layersDiv.appendChild(layerDiv);
            });
        }

        // Delete layer
        function deleteLayer(layerId) {
            const layerIndex = imageLayers.findIndex(layer => layer.id === layerId);
            if (layerIndex === -1) return;

            const layer = imageLayers[layerIndex];
            scene.remove(layer.mesh);
            imageLayers.splice(layerIndex, 1);

            if (selectedLayer && selectedLayer.id === layerId) {
                selectedLayer = null;
            }

            updateLayersList();
        }

        // Select layer
        function selectLayer(layer) {
            selectedLayer = layer;

            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('selected');
            });

            const layerItems = document.querySelectorAll('.layer-item');
            if (layerItems[imageLayers.indexOf(layer)]) {
                layerItems[imageLayers.indexOf(layer)].classList.add('selected');
            }

            // Update controls to match selected layer
            const pos = layer.mesh.position;
            const rot = layer.mesh.rotation;
            const scale = layer.mesh.scale.x;
            const alpha = layer.mesh.material.opacity;

            document.getElementById('xPos').value = pos.x;
            document.getElementById('yPos').value = pos.y;
            document.getElementById('zPos').value = pos.z;
            document.getElementById('rotX').value = rot.x * 180 / Math.PI;
            document.getElementById('rotY').value = rot.y * 180 / Math.PI;
            document.getElementById('rotZ').value = rot.z * 180 / Math.PI;
            document.getElementById('scale').value = scale;
            document.getElementById('alpha').value = alpha;
            document.getElementById('enableCustomAnimation').checked = layer.enableCustomAnimation;
            document.getElementById('specialEffect').value = layer.specialEffect;
            document.getElementById('animationSpeed').value = layer.animationSpeed;
            document.getElementById('animationDuration').value = layer.animationDuration;
            document.getElementById('loopAnimation').checked = layer.loopAnimation;

            // Update custom animation controls
            const custom = layer.customAnimation;
            document.getElementById('startX').value = custom.start.x;
            document.getElementById('startY').value = custom.start.y;
            document.getElementById('startZ').value = custom.start.z;
            document.getElementById('startScale').value = custom.start.scale;
            document.getElementById('startOpacity').value = custom.start.opacity;
            document.getElementById('startRotation').value = custom.start.rotation;

            document.getElementById('endX').value = custom.end.x;
            document.getElementById('endY').value = custom.end.y;
            document.getElementById('endZ').value = custom.end.z;
            document.getElementById('endScale').value = custom.end.scale;
            document.getElementById('endOpacity').value = custom.end.opacity;
            document.getElementById('endRotation').value = custom.end.rotation;

            toggleCustomControls();
            updateControlValues();
        }

        // Toggle custom controls visibility
        function toggleCustomControls() {
            const customControls = document.getElementById('customAnimationControls');
            const enableCustom = document.getElementById('enableCustomAnimation').checked;
            customControls.style.display = enableCustom ? 'block' : 'none';

            if (selectedLayer) {
                selectedLayer.enableCustomAnimation = enableCustom;
            }
        }

        // Update special effect
        function updateSpecialEffect() {
            if (selectedLayer) {
                selectedLayer.specialEffect = document.getElementById('specialEffect').value;
            }
        }

        // Update control value displays
        function updateControlValues() {
            document.getElementById('xValue').textContent = document.getElementById('xPos').value;
            document.getElementById('yValue').textContent = document.getElementById('yPos').value;
            document.getElementById('zValue').textContent = document.getElementById('zPos').value;
            document.getElementById('rotXValue').textContent = document.getElementById('rotX').value + '°';
            document.getElementById('rotYValue').textContent = document.getElementById('rotY').value + '°';
            document.getElementById('rotZValue').textContent = document.getElementById('rotZ').value + '°';
            document.getElementById('scaleValue').textContent = document.getElementById('scale').value;
            document.getElementById('alphaValue').textContent = document.getElementById('alpha').value;
            document.getElementById('speedValue').textContent = document.getElementById('animationSpeed').value;
            document.getElementById('durationValue').textContent = document.getElementById('animationDuration').value;

            updateCustomValues();
        }

        // Update custom animation values
        function updateCustomValues() {
            document.getElementById('startXValue').textContent = document.getElementById('startX').value;
            document.getElementById('startYValue').textContent = document.getElementById('startY').value;
            document.getElementById('startZValue').textContent = document.getElementById('startZ').value;
            document.getElementById('startScaleValue').textContent = document.getElementById('startScale').value;
            document.getElementById('startOpacityValue').textContent = document.getElementById('startOpacity').value;
            document.getElementById('startRotationValue').textContent = document.getElementById('startRotation').value;

            document.getElementById('endXValue').textContent = document.getElementById('endX').value;
            document.getElementById('endYValue').textContent = document.getElementById('endY').value;
            document.getElementById('endZValue').textContent = document.getElementById('endZ').value;
            document.getElementById('endScaleValue').textContent = document.getElementById('endScale').value;
            document.getElementById('endOpacityValue').textContent = document.getElementById('endOpacity').value;
            document.getElementById('endRotationValue').textContent = document.getElementById('endRotation').value;

            if (selectedLayer) {
                selectedLayer.customAnimation = {
                    start: {
                        x: parseFloat(document.getElementById('startX').value),
                        y: parseFloat(document.getElementById('startY').value),
                        z: parseFloat(document.getElementById('startZ').value),
                        scale: parseFloat(document.getElementById('startScale').value),
                        opacity: parseFloat(document.getElementById('startOpacity').value),
                        rotation: parseFloat(document.getElementById('startRotation').value)
                    },
                    end: {
                        x: parseFloat(document.getElementById('endX').value),
                        y: parseFloat(document.getElementById('endY').value),
                        z: parseFloat(document.getElementById('endZ').value),
                        scale: parseFloat(document.getElementById('endScale').value),
                        opacity: parseFloat(document.getElementById('endOpacity').value),
                        rotation: parseFloat(document.getElementById('endRotation').value)
                    }
                };
            }
        }

        // Update position
        function updatePosition() {
            if (!selectedLayer) return;

            const x = parseFloat(document.getElementById('xPos').value);
            const y = parseFloat(document.getElementById('yPos').value);
            const z = parseFloat(document.getElementById('zPos').value);

            selectedLayer.mesh.position.set(x, y, z);
            selectedLayer.originalPosition = { x, y, z };
            updateControlValues();
        }

        // Update rotation
        function updateRotation() {
            if (!selectedLayer) return;

            const x = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
            const y = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
            const z = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;

            selectedLayer.mesh.rotation.set(x, y, z);
            selectedLayer.originalRotation = { x, y, z };
            updateControlValues();
        }

        // Update transparency
        function updateTransparency() {
            if (!selectedLayer) return;

            const alpha = parseFloat(document.getElementById('alpha').value);
            selectedLayer.mesh.material.opacity = alpha;
            selectedLayer.originalOpacity = alpha;
            updateControlValues();
        }

        // Update scale
        function updateScale() {
            if (!selectedLayer) return;

            const scale = parseFloat(document.getElementById('scale').value);
            selectedLayer.mesh.scale.set(scale, scale, scale);
            selectedLayer.originalScale = { x: scale, y: scale, z: scale };
            updateControlValues();
        }

        // Update animation speed
        function updateAnimationSpeed() {
            if (!selectedLayer) return;
            selectedLayer.animationSpeed = parseFloat(document.getElementById('animationSpeed').value);
            updateControlValues();
        }

        // Update animation duration
        function updateAnimationDuration() {
            if (!selectedLayer) return;
            selectedLayer.animationDuration = parseFloat(document.getElementById('animationDuration').value);
            updateControlValues();
        }

        // Save current layer settings (including loop)
        function saveCurrentLayerSettings() {
            if (!selectedLayer) return;

            selectedLayer.loopAnimation = document.getElementById('loopAnimation').checked;
            selectedLayer.enableCustomAnimation = document.getElementById('enableCustomAnimation').checked;
            selectedLayer.specialEffect = document.getElementById('specialEffect').value;
            selectedLayer.animationSpeed = parseFloat(document.getElementById('animationSpeed').value);
            selectedLayer.animationDuration = parseFloat(document.getElementById('animationDuration').value);
        }

        // Create animation for a specific layer
        function createAnimationForLayer(layer) {
            if (!layer.enableCustomAnimation && layer.specialEffect === 'none') {
                return null;
            }

            const mesh = layer.mesh;
            const duration = layer.animationDuration;
            const speed = layer.animationSpeed;
            const loop = layer.loopAnimation;

            const startTime = Date.now();
            return {
                stop: () => { layer.animation = null; },
                update: (currentTime) => {
                    const elapsed = (currentTime - startTime) / 1000 * speed;
                    let progress = (elapsed % duration) / duration;

                    if (!loop && elapsed > duration) {
                        progress = 1;
                    }

                    const easeInOut = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    const easedProgress = easeInOut(progress);

                    // Start with original position/properties
                    let finalX = layer.originalPosition.x;
                    let finalY = layer.originalPosition.y;
                    let finalZ = layer.originalPosition.z;
                    let finalRotX = layer.originalRotation.x;
                    let finalRotY = layer.originalRotation.y;
                    let finalRotZ = layer.originalRotation.z;
                    let finalScaleX = layer.originalScale.x;
                    let finalScaleY = layer.originalScale.y;
                    let finalScaleZ = layer.originalScale.z;
                    let finalOpacity = layer.originalOpacity;

                    // Apply custom animation if enabled
                    if (layer.enableCustomAnimation) {
                        const start = layer.customAnimation.start;
                        const end = layer.customAnimation.end;

                        // Interpolate custom position
                        finalX = start.x + (end.x - start.x) * easedProgress;
                        finalY = start.y + (end.y - start.y) * easedProgress;
                        finalZ = start.z + (end.z - start.z) * easedProgress;

                        // Interpolate custom scale
                        const customScale = start.scale + (end.scale - start.scale) * easedProgress;
                        finalScaleX = finalScaleY = finalScaleZ = customScale;

                        // Interpolate custom opacity
                        finalOpacity = start.opacity + (end.opacity - start.opacity) * easedProgress;

                        // Interpolate custom rotation
                        finalRotZ = (start.rotation + (end.rotation - start.rotation) * easedProgress) * Math.PI / 180;
                    }

                    // Apply special effects on top of custom animation
                    if (layer.specialEffect !== 'none') {
                        switch (layer.specialEffect) {
                            case 'swingToTarget':
                                // Add swing rotation effect
                                const swingFrequency = 8;
                                const swingAmplitude = (1 - easedProgress) * 90;
                                const swingAngle = Math.sin(progress * swingFrequency * Math.PI) * swingAmplitude;
                                finalRotZ += (swingAngle * Math.PI / 180);

                                // If no custom animation, move to a target
                                if (!layer.enableCustomAnimation) {
                                    finalX += 5 * easedProgress;
                                }
                                break;

                            case 'zigzagToTarget':
                                // Add zigzag movement
                                const zigzagFrequency = 6;
                                const zigzagAmplitude = (1 - easedProgress) * 2;
                                const zigzagOffset = Math.sin(progress * zigzagFrequency * Math.PI) * zigzagAmplitude;
                                finalX += zigzagOffset;

                                // If no custom animation, move to a target
                                if (!layer.enableCustomAnimation) {
                                    finalX += 5 * easedProgress;
                                    finalY += 3 * easedProgress;
                                }
                                break;

                            case 'pendulumMove':
                                // Pendulum swinging
                                const pendulumAmplitude = 60;
                                const pendulumAngle = Math.sin(elapsed * 2) * pendulumAmplitude;
                                finalRotZ += (pendulumAngle * Math.PI / 180);
                                break;

                            case 'waveToTarget':
                                // Wave effect
                                const waveAmplitude = 1.5;
                                const waveFrequency = 4;
                                const waveY = Math.sin(progress * waveFrequency * Math.PI) * waveAmplitude * (1 - easedProgress);
                                finalY += waveY;
                                finalRotZ += (waveY * 0.2);

                                // If no custom animation, move to a target
                                if (!layer.enableCustomAnimation) {
                                    finalX += 4 * easedProgress;
                                    finalY += 2 * easedProgress;
                                }
                                break;

                            case 'elasticMove':
                                // Elastic effect
                                const scaleElastic = 1 + Math.sin(progress * 10) * 0.1 * (1 - progress);
                                finalScaleX *= scaleElastic;
                                finalScaleY *= scaleElastic;
                                finalScaleZ *= scaleElastic;

                                // If no custom animation, move to a target with elastic easing
                                if (!layer.enableCustomAnimation) {
                                    const elasticEase = (t) => {
                                        if (t === 0) return 0;
                                        if (t === 1) return 1;
                                        const c4 = (2 * Math.PI) / 3;
                                        return t < 0.5
                                            ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c4)) / 2
                                            : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c4)) / 2 + 1;
                                    };
                                    const elasticProgress = elasticEase(progress);
                                    finalX += 3 * elasticProgress;
                                    finalY += 3 * elasticProgress;
                                }
                                break;

                            case 'slideDown':
                                finalY += 10 * (1 - easedProgress);
                                break;
                            case 'slideUp':
                                finalY -= 10 * (1 - easedProgress);
                                break;
                            case 'slideLeft':
                                finalX += 10 * (1 - easedProgress);
                                break;
                            case 'slideRight':
                                finalX -= 10 * (1 - easedProgress);
                                break;
                            case 'fadeIn':
                                finalOpacity *= easedProgress;
                                break;
                            case 'scaleIn':
                                const scaleInFactor = easedProgress;
                                finalScaleX *= scaleInFactor;
                                finalScaleY *= scaleInFactor;
                                finalScaleZ *= scaleInFactor;
                                break;
                            case 'rotate':
                                finalRotZ += easedProgress * Math.PI * 2;
                                break;
                            case 'bounce':
                                const bounceY = Math.abs(Math.sin(easedProgress * Math.PI * 4)) * 2;
                                finalY += bounceY;
                                break;
                            case 'spiral':
                                const spiralRadius = 3 * (1 - easedProgress);
                                const spiralAngle = easedProgress * Math.PI * 6;
                                finalX += spiralRadius * Math.cos(spiralAngle);
                                finalY += spiralRadius * Math.sin(spiralAngle);
                                break;
                        }
                    }

                    // Apply final transformations
                    mesh.position.set(finalX, finalY, finalZ);
                    mesh.rotation.set(finalRotX, finalRotY, finalRotZ);
                    mesh.scale.set(finalScaleX, finalScaleY, finalScaleZ);
                    mesh.material.opacity = finalOpacity;
                }
            };
        }

        // Apply animation
        function applyAnimation() {
            if (!selectedLayer) return;

            // Save current settings to the layer
            saveCurrentLayerSettings();

            if (selectedLayer.animation) {
                selectedLayer.animation.stop();
            }

            selectedLayer.animation = createAnimationForLayer(selectedLayer);
        }

        // Preview animation (single run)
        function previewAnimation() {
            if (!selectedLayer) return;

            // Save current loop setting and temporarily disable it
            const originalLoop = selectedLayer.loopAnimation;
            selectedLayer.loopAnimation = false;

            applyAnimation();

            // Restore original loop setting after animation completes
            setTimeout(() => {
                selectedLayer.loopAnimation = originalLoop;
            }, selectedLayer.animationDuration * 1000);
        }

        // Stop animation for selected layer
        function stopAnimation() {
            if (!selectedLayer || !selectedLayer.animation) return;
            selectedLayer.animation.stop();
        }

        // Play all animations - now uses each layer's individual settings
        function playAllAnimations() {
            imageLayers.forEach(layer => {
                if (layer.enableCustomAnimation || layer.specialEffect !== 'none') {
                    // Stop any existing animation for this layer
                    if (layer.animation) {
                        layer.animation.stop();
                    }

                    // Create and start new animation using the layer's own settings
                    layer.animation = createAnimationForLayer(layer);
                    console.log('Playing animation for layer:', layer.name, 'with settings:', {
                        enableCustomAnimation: layer.enableCustomAnimation,
                        specialEffect: layer.specialEffect,
                        duration: layer.animationDuration,
                        speed: layer.animationSpeed,
                        loop: layer.loopAnimation
                    });
                }
            });
        }

        // Stop all animations
        function stopAllAnimations() {
            imageLayers.forEach(layer => {
                console.log('Stopping animation for layer:', layer.name);
                if (layer.animation) {
                    layer.animation.stop();
                }

            });
        }

        // Reset camera
        function resetCamera() {
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        }


        function generateHTMLContent() {
            const name = (document.getElementById('projectName').value || 'AR_Project').trim();
            const bgColor = document.getElementById('bgColor').value;

            let htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${name} - AR Experience</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"><\/script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"><\/script>
    <style>
        .ar-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        .ar-controls button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background: #0066cc;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .ar-controls button:hover {
            background: #0052a3;
        }
            
    </style>
</head>

<body>

    <div class="ar-controls">
        <button onclick="playAllAnimations()">Play All Animations</button>
        <button onclick="stopAllAnimations()">Stop Animations</button>
    </div>

    <a-scene vr-mode-ui="enabled: false" embedded
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3; trackingMethod: best; maxDetectionRate: 60; canvasWidth: 640; canvasHeight: 480;"
        renderer="logarithmicDepthBuffer: true; colorManagement: true; sortObjects: true;"
        background="color: #000000; transparent: true">

        <a-assets>`;

            // Add audio asset if exists
            if (backgroundAudio) {
                htmlContent += `
            <audio id="background-audio" src="audio/${backgroundAudio.fileName}" loop autoplay></audio>`;
            }

            // Add image assets
            imageLayers.forEach(layer => {
                htmlContent += `
            <img id="img-${layer.id}" src="images/${layer.name}" crossorigin="anonymous">`;
            });

            htmlContent += `
        </a-assets>

        <a-marker type="pattern" url="pattern-${name}-qr-code.patt">`;

            // Add each layer as A-Frame entities
            imageLayers.forEach(layer => {
                const pos = layer.originalPosition;
                const rot = layer.originalRotation;
                const scale = layer.originalScale;
                const opacity = layer.originalOpacity;

                // Convert rotation from radians to degrees
                const rotX = (rot.x * 180 / Math.PI).toFixed(2);
                const rotY = (rot.y * 180 / Math.PI).toFixed(2);
                const rotZ = (rot.z * 180 / Math.PI).toFixed(2);

                // Properly escape JSON data for HTML attributes
                const customStartJSON = JSON.stringify(layer.customAnimation.start).replace(/"/g, '&quot;');
                const customEndJSON = JSON.stringify(layer.customAnimation.end).replace(/"/g, '&quot;');

                htmlContent += `
            <a-plane id="layer-${layer.id}" src="#img-${layer.id}"
                position="${pos.x.toFixed(2)} ${pos.y.toFixed(2)} ${pos.z.toFixed(2)}"
                rotation="${rotX} ${rotY} ${rotZ}"
                scale="${scale.x.toFixed(2)} ${scale.y.toFixed(2)} ${scale.z.toFixed(2)}"
                material="transparent: true; opacity: ${opacity.toFixed(2)}"
                data-animation-enabled="${layer.enableCustomAnimation}" 
                data-special-effect="${layer.specialEffect}"
                data-animation-speed="${layer.animationSpeed}" 
                data-animation-duration="${layer.animationDuration}"
                data-loop-animation="${layer.loopAnimation}"
                data-custom-start="${customStartJSON}"
                data-custom-end="${customEndJSON}">
            </a-plane>`;
            });

            htmlContent += `
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
    let animationIntervals = [];
    let markerVisible = false;

    document.querySelector('a-marker').addEventListener('markerFound', function() {
        markerVisible = true;
        console.log('Marker found - starting animations and audio');
        
        // Start background audio if exists
        const audio = document.querySelector('#background-audio');
        if (audio) {
            audio.play().catch(e => console.log('Audio autoplay blocked:', e));
        }
        
        playAllAnimations();
    });

       
    document.querySelector('a-marker').addEventListener('markerLost', function() {
        markerVisible = false;
        console.log('Marker lost - stopping animations and audio');
        
        // Stop background audio if exists
        const audio = document.querySelector('#background-audio');
        if (audio) {
            audio.pause();
        }
        
    });
    
    function playAllAnimations() {
        stopAllAnimations();
        
        const layers = document.querySelectorAll('[id^="layer-"]');
        layers.forEach(layer => {
            const enableCustom = layer.getAttribute('data-animation-enabled') === 'true';
            const specialEffect = layer.getAttribute('data-special-effect');
            
            if (enableCustom || specialEffect !== 'none') {
                const speed = parseFloat(layer.getAttribute('data-animation-speed'));
                const duration = parseFloat(layer.getAttribute('data-animation-duration'));
                const loop = layer.getAttribute('data-loop-animation') === 'true';
                
                const startTime = Date.now();
                
                const interval = setInterval(() => {
                    const currentTime = Date.now();
                    const elapsed = (currentTime - startTime) / 1000 * speed;
                    let progress = (elapsed % duration) / duration;
                    
                    if (!loop && elapsed > duration) {
                        clearInterval(interval);
                        return;
                    }
                    
                        const easeInOut = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                        const easedProgress = easeInOut(progress);

                        const originalPos = layer.getAttribute('position');
                        const originalRot = layer.getAttribute('rotation');
                        const originalScale = layer.getAttribute('scale');
                        const origX = originalPos.x, origY = originalPos.y, origZ = originalPos.z;
                        const origRotX = originalRot.x, origRotY = originalRot.y, origRotZ = originalRot.z;
                        const origScaleX = originalScale.x, origScaleY = originalScale.y, origScaleZ = originalScale.z;

                        let finalX = origX, finalY = origY, finalZ = origZ;
                        let finalRotX = origRotX, finalRotY = origRotY, finalRotZ = origRotZ;
                        let finalScaleX = origScaleX, finalScaleY = origScaleY, finalScaleZ = origScaleZ;
                
                    
                    if (enableCustom) {
                        try {
                            const customStart = JSON.parse(layer.getAttribute('data-custom-start').replace(/&quot;/g, '"'));
                            const customEnd = JSON.parse(layer.getAttribute('data-custom-end').replace(/&quot;/g, '"'));
                            
                            finalX = customStart.x + (customEnd.x - customStart.x) * easedProgress;
                            finalY = customStart.y + (customEnd.y - customStart.y) * easedProgress;
                            finalZ = customStart.z + (customEnd.z - customStart.z) * easedProgress;
                            
                            const customScale = customStart.scale + (customEnd.scale - customStart.scale) * easedProgress;
                            finalScaleX = finalScaleY = finalScaleZ = customScale;
                            
                            finalRotZ = customStart.rotation + (customEnd.rotation - customStart.rotation) * easedProgress;
                        } catch (e) {
                            console.error('Error parsing custom animation data:', e);
                        }
                    }
                    
                    // Apply special effects
                    if (specialEffect !== 'none') {
                        switch (specialEffect) {
                            case 'swingToTarget':
                                // Add swing rotation effect
                                const swingFrequency = 8;
                                const swingAmplitude = (1 - easedProgress) * 90;
                                const swingAngle = Math.sin(progress * swingFrequency * Math.PI) * swingAmplitude;
                                finalRotZ += (swingAngle * Math.PI / 180);

                                // If no custom animation, move to a target
                                if (!layer.enableCustomAnimation) {
                                    finalX += 5 * easedProgress;
                                }
                                break;

                            case 'zigzagToTarget':
                                // Add zigzag movement
                                const zigzagFrequency = 6;
                                const zigzagAmplitude = (1 - easedProgress) * 2;
                                const zigzagOffset = Math.sin(progress * zigzagFrequency * Math.PI) * zigzagAmplitude;
                                finalX += zigzagOffset;

                                // If no custom animation, move to a target
                                if (!layer.enableCustomAnimation) {
                                    finalX += 5 * easedProgress;
                                    finalY += 3 * easedProgress;
                                }
                                break;

                            case 'pendulumMove':
                                // Pendulum swinging
                                const pendulumAmplitude = 60;
                                const pendulumAngle = Math.sin(elapsed * 2) * pendulumAmplitude;
                                finalRotZ += (pendulumAngle * Math.PI / 180);
                                break;

                            case 'waveToTarget':
                                // Wave effect
                                const waveAmplitude = 1.5;
                                const waveFrequency = 4;
                                const waveY = Math.sin(progress * waveFrequency * Math.PI) * waveAmplitude * (1 - easedProgress);
                                finalY += waveY;
                                finalRotZ += (waveY * 0.2);

                                // If no custom animation, move to a target
                                if (!layer.enableCustomAnimation) {
                                    finalX += 4 * easedProgress;
                                    finalY += 2 * easedProgress;
                                }
                                break;

                            case 'elasticMove':
                                // Elastic effect
                                const scaleElastic = 1 + Math.sin(progress * 10) * 0.1 * (1 - progress);
                                finalScaleX *= scaleElastic;
                                finalScaleY *= scaleElastic;
                                finalScaleZ *= scaleElastic;

                                // If no custom animation, move to a target with elastic easing
                                if (!layer.enableCustomAnimation) {
                                    const elasticEase = (t) => {
                                        if (t === 0) return 0;
                                        if (t === 1) return 1;
                                        const c4 = (2 * Math.PI) / 3;
                                        return t < 0.5
                                            ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c4)) / 2
                                            : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c4)) / 2 + 1;
                                    };
                                    const elasticProgress = elasticEase(progress);
                                    finalX += 3 * elasticProgress;
                                    finalY += 3 * elasticProgress;
                                }
                                break;

                            case 'slideDown':
                                finalY += 10 * (1 - easedProgress);
                                break;
                            case 'slideUp':
                                finalY -= 10 * (1 - easedProgress);
                                break;
                            case 'slideLeft':
                                finalX += 10 * (1 - easedProgress);
                                break;
                            case 'slideRight':
                                finalX -= 10 * (1 - easedProgress);
                                break;
                            case 'fadeIn':
                                finalOpacity *= easedProgress;
                                break;
                            case 'scaleIn':
                                const scaleInFactor = easedProgress;
                                finalScaleX *= scaleInFactor;
                                finalScaleY *= scaleInFactor;
                                finalScaleZ *= scaleInFactor;
                                break;
                            case 'rotate':
                                finalRotZ += easedProgress * Math.PI * 2;
                                break;
                            case 'bounce':
                                const bounceY = Math.abs(Math.sin(easedProgress * Math.PI * 4)) * 2;
                                finalY += bounceY;
                                break;
                            case 'spiral':
                                const spiralRadius = 3 * (1 - easedProgress);
                                const spiralAngle = easedProgress * Math.PI * 6;
                                finalX += spiralRadius * Math.cos(spiralAngle);
                                finalY += spiralRadius * Math.sin(spiralAngle);
                                break;
                        }
                    }
                    
                    // Update layer position, rotation, and scale
                    layer.setAttribute('position', finalX + ' ' + finalY + ' ' + finalZ);
                    layer.setAttribute('rotation', finalRotX + ' ' + finalRotY + ' ' + finalRotZ);
                    layer.setAttribute('scale', finalScaleX + ' ' + finalScaleY + ' ' + finalScaleZ);
                    
                }, 16); // ~60fps
                
                animationIntervals.push(interval);
            }
        });
    }
    
    function stopAllAnimations() {
        animationIntervals.forEach(interval => clearInterval(interval));
        animationIntervals = [];
    }
    
    <\/script>
</body>
</html>`;

            return htmlContent;
        }

        async function exportAsAR() {
            const name = (document.getElementById('projectName').value || 'AR_Project').trim();
            const zip = new JSZip();

            zip.file(name + '.html', generateHTMLContent());
            const imageFiles = zip.folder('images');
            for (const layer of imageLayers) {
                if (layer.texture.image && layer.texture.image.src) {
                    const img = layer.texture.image;
                    const canvas = document.createElement('canvas');
                    canvas.width = img.naturalWidth || img.width;
                    canvas.height = img.naturalHeight || img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imgBlob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    imageFiles.file(layer.name, imgBlob);
                }
            }

            if (backgroundAudio) {
                const audioFiles = zip.folder('audio');
                audioFiles.file(backgroundAudio.fileName, backgroundAudio.blob);
            }

            const url = document.getElementById('websiteUrl').value.trim();
            if (url) {
                try {
                    const qr = qrcode(0, 'M');
                    qr.addData(url);
                    qr.make();

                    // Create canvas for QR code
                    const qrCanvas = document.createElement('canvas');
                    const size = 512;
                    qrCanvas.width = size;
                    qrCanvas.height = size;

                    const ctx = qrCanvas.getContext('2d');
                    const moduleCount = qr.getModuleCount();
                    const moduleSize = size / moduleCount;

                    // Fill white background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, size, size);

                    // Draw black modules
                    ctx.fillStyle = '#000000';
                    for (let row = 0; row < moduleCount; row++) {
                        for (let col = 0; col < moduleCount; col++) {
                            if (qr.isDark(row, col)) {
                                ctx.fillRect(col * moduleSize, row * moduleSize, moduleSize, moduleSize);
                            }
                        }
                    }
                    const qrBlob = await new Promise(resolve => {
                        qrCanvas.toBlob(resolve, 'image/png');
                    });

                    zip.file(name + '-qr-code.png', qrBlob);
                } catch (error) {
                    console.error('Error generating QR code for package:', error);
                }
            }

            // Save the zip file
            zip.generateAsync({ type: "blob" }).then(function (content) {
                saveAs(content, name + "_AR_Package.zip");
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();

            // Update animations
            imageLayers.forEach(layer => {
                if (layer.animation && layer.animation.update) {
                    layer.animation.update(currentTime);
                }
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize scene when page loads
        window.addEventListener('load', initScene);
    </script>
</body>

</html>