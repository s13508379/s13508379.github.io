<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>project - AR Experience</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
    <style>
        .ar-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        .ar-controls button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background: #0066cc;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .ar-controls button:hover {
            background: #0052a3;
        }
    </style>
</head>

<body>
    <div class="ar-controls">
        <button onclick="playAllAnimations()">Play All Animations</button>
        <button onclick="stopAllAnimations()">Stop Animations</button>
    </div>

    <a-scene vr-mode-ui="enabled: false" embedded
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3; trackingMethod: best; maxDetectionRate: 60; canvasWidth: 640; canvasHeight: 480;"
        renderer="logarithmicDepthBuffer: true; colorManagement: true; sortObjects: true;"
        background="color: #000000; transparent: true">

        <a-assets>
            <img id="img-0" src="images/allimg.png" crossorigin="anonymous">
            <audio id="audio-audio_1752484509673_9s4ftvf5e" src="audio/sound.mp3" preload="auto"></audio>
            <audio id="audio-audio_1752484509674_d684gl199" src="audio/title.mp3" preload="auto"></audio>
            <audio id="audio-audio_1752484509675_bif20w0hu" src="audio/title-large.mp3" preload="auto"></audio>
        </a-assets>

        <a-marker type="pattern" url="pattern-project-qr-code.patt">
            <a-plane id="layer-0" src="#img-0"
                position="0.00 0.00 0.00"
                rotation="88.00 0.00 0.00"
                scale="1.00 1.00 1.00"
                material="transparent: true; opacity: 1.00"
                data-animation-enabled="true" 
                data-special-effect="swingToTarget"
                data-animation-speed="1" 
                data-animation-duration="2"
                data-loop-animation="true"
                data-custom-start="{&quot;x&quot;:0,&quot;y&quot;:1.3,&quot;z&quot;:0,&quot;scale&quot;:2.4,&quot;opacity&quot;:1,&quot;rotation&quot;:-90}"
                data-custom-end="{&quot;x&quot;:2.5,&quot;y&quot;:1.3,&quot;z&quot;:0,&quot;scale&quot;:2.4,&quot;opacity&quot;:1,&quot;rotation&quot;:-90}"
                data-special-settings="{&quot;swingRange&quot;:90,&quot;swingFreq&quot;:8,&quot;swingTargetX&quot;:2,&quot;zigzagAmp&quot;:2,&quot;zigzagFreq&quot;:6,&quot;zigzagTargetX&quot;:5,&quot;zigzagTargetY&quot;:3,&quot;pendulumRange&quot;:60,&quot;pendulumSpeed&quot;:2,&quot;waveAmp&quot;:1.5,&quot;waveFreq&quot;:4,&quot;waveTargetX&quot;:4,&quot;waveTargetY&quot;:2,&quot;bounceHeight&quot;:2,&quot;bounceFreq&quot;:4,&quot;spiralRadius&quot;:3,&quot;spiralRotations&quot;:6,&quot;slideDistance&quot;:10,&quot;rotateCycles&quot;:1}"
                data-original-position="{&quot;x&quot;:0,&quot;y&quot;:0,&quot;z&quot;:0}"
                data-original-rotation="{&quot;x&quot;:1.53588974175501,&quot;y&quot;:0,&quot;z&quot;:0}"
                data-original-scale="{&quot;x&quot;:1,&quot;y&quot;:1,&quot;z&quot;:1}"
                data-original-opacity="1.00">
            </a-plane>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
    let animationIntervals = [];
    let audioTracks = [];
    let markerVisible = false;
    let backgroundAudioTrack = null;
    let currentSequentialIndex = 0;
    let sequentialAudioInterval = null;
    let sequenceLoopActive = false;

    // Initialize audio tracks from HTML audio elements
    function initializeAudioTracks() {
        audioTracks = [];
        audioTracks.push({
            id: "audio_1752484509673_9s4ftvf5e",
            name: "sound.mp3",
            audio: document.getElementById("audio-audio_1752484509673_9s4ftvf5e"),
            playOrder: 1,
            loop: false,
            isBackground: true,
            startTime: 2,
            endTime: 18.133333,
            timelineMode: true,
            volume: 0.8,
            isPlaying: false
        });
        audioTracks.push({
            id: "audio_1752484509674_d684gl199",
            name: "title.mp3",
            audio: document.getElementById("audio-audio_1752484509674_d684gl199"),
            playOrder: 2,
            loop: true,
            isBackground: false,
            startTime: 2,
            endTime: 3.584,
            timelineMode: true,
            volume: 0.8,
            isPlaying: false
        });
        audioTracks.push({
            id: "audio_1752484509675_bif20w0hu",
            name: "title-large.mp3",
            audio: document.getElementById("audio-audio_1752484509675_bif20w0hu"),
            playOrder: 3,
            loop: true,
            isBackground: false,
            startTime: 1,
            endTime: 3.584,
            timelineMode: true,
            volume: 0.8,
            isPlaying: false
        });
        
        // Set audio properties
        audioTracks.forEach(track => {
            track.audio.volume = track.volume;
            if (track.isBackground) {
                track.audio.loop = true;
                backgroundAudioTrack = track;
            }
        });
        
        console.log('Initialized', audioTracks.length, 'audio tracks');
    }

    // Call initialization when page loads
    window.addEventListener('load', initializeAudioTracks);

    document.querySelector('a-marker').addEventListener('markerFound', function() {
        markerVisible = true;
        console.log('Marker found - starting animations and audio');
        
        // Start background audio if exists
        if (backgroundAudioTrack && backgroundAudioTrack.audio) {
            backgroundAudioTrack.audio.play().catch(e => console.log('Background audio autoplay blocked:', e));
            backgroundAudioTrack.isPlaying = true;
        }
        
        // Auto-start sequential audio playback based on settings
        playSequentialAudio();
        playAllAnimations();
    });

    document.querySelector('a-marker').addEventListener('markerLost', function() {
        markerVisible = false;
        console.log('Marker lost - stopping animations and audio');
        
        // Stop all audio
        stopAllAudio();
        stopAllAnimations();
    });

    function playSequentialAudio() {
        if (audioTracks.length === 0) {
            console.log('No audio tracks available');
            return;
        }

        // Don't stop background music, only stop regular tracks
        audioTracks.forEach(track => {
            if (!track.isBackground && track.isPlaying) {
                track.audio.pause();
                track.isPlaying = false;
                if (track.timelineMode && track.startTime > 0) {
                    track.audio.currentTime = track.startTime;
                } else {
                    track.audio.currentTime = 0;
                }
            }
        });
        
        const regularTracks = audioTracks
            .filter(track => !track.isBackground)
            .sort((a, b) => a.playOrder - b.playOrder);

        if (regularTracks.length === 0) {
            console.log('No regular tracks to play');
            return;
        }

        currentSequentialIndex = 0;
        sequenceLoopActive = true;
        playNextInSequence(regularTracks);
    }

    function playNextInSequence(tracks) {
        if (!sequenceLoopActive) return;
        
        if (currentSequentialIndex >= tracks.length) {
            // Check if any track in the sequence has loop enabled
            const hasLoopTracks = tracks.some(t => t.loop);
            if (hasLoopTracks) {
                console.log('Restarting sequence due to loop tracks');
                currentSequentialIndex = 0;
                playNextInSequence(tracks);
                return;
            }
            console.log('Sequential playback complete');
            sequenceLoopActive = false;
            return;
        }

        const track = tracks[currentSequentialIndex];
        console.log('Playing track:', track.name, 'Order:', track.playOrder);

        playTrack(track, () => {
            // Move to next track after current one finishes
            currentSequentialIndex++;
            setTimeout(() => {
                playNextInSequence(tracks);
            }, 100);
        });
    }

    function playTrack(track, onComplete) {
        if (!sequenceLoopActive) return;
        
        // Set start time if timeline mode
        if (track.timelineMode && track.startTime > 0) {
            track.audio.currentTime = track.startTime;
        }

        track.audio.play().catch(e => console.log('Audio play error:', e));
        track.isPlaying = true;

        // Set up end listener
        const onEnded = () => {
            track.audio.removeEventListener('ended', onEnded);
            track.audio.removeEventListener('timeupdate', onTimeUpdate);
            track.isPlaying = false;
            
            if (onComplete) {
                onComplete();
            }
        };

        const onTimeUpdate = () => {
            if (track.timelineMode && track.endTime && track.audio.currentTime >= track.endTime) {
                track.audio.pause();
                onEnded();
            }
        };

        track.audio.addEventListener('ended', onEnded);
        if (track.timelineMode && track.endTime) {
            track.audio.addEventListener('timeupdate', onTimeUpdate);
        }
    }

    function stopAllAudio() {
        sequenceLoopActive = false;
        
        if (sequentialAudioInterval) {
            clearInterval(sequentialAudioInterval);
            sequentialAudioInterval = null;
        }

        audioTracks.forEach(track => {
            track.audio.pause();
            track.isPlaying = false;
            
            if (track.timelineMode && track.startTime > 0) {
                track.audio.currentTime = track.startTime;
            } else {
                track.audio.currentTime = 0;
            }
        });

        currentSequentialIndex = 0;
        console.log('All audio stopped');
    }

    function toggleBackgroundAudio() {
        if (!backgroundAudioTrack) {
            console.log('No background audio track available');
            return;
        }

        if (backgroundAudioTrack.isPlaying) {
            backgroundAudioTrack.audio.pause();
            backgroundAudioTrack.isPlaying = false;
            console.log('Background audio paused');
        } else {
            backgroundAudioTrack.audio.play().catch(e => console.log('Background audio play error:', e));
            backgroundAudioTrack.isPlaying = true;
            console.log('Background audio playing');
        }
    }

    function playAllAnimations() {
       stopAllAnimations();
        const layers = document.querySelectorAll('[id^="layer-"]');
        layers.forEach(layer => {
            const enableCustom = layer.getAttribute('data-animation-enabled') === 'true';
            const specialEffect = layer.getAttribute('data-special-effect');
            
            if (enableCustom || specialEffect !== 'none') {
                const speed = parseFloat(layer.getAttribute('data-animation-speed'));
                const duration = parseFloat(layer.getAttribute('data-animation-duration'));
                const loop = layer.getAttribute('data-loop-animation') === 'true';
                
                // Parse special effect settings
                let settings = {};
                try {
                    settings = JSON.parse(layer.getAttribute('data-special-settings').replace(/&quot;/g, '"'));
                } catch (e) {
                    console.error('Error parsing special effect settings:', e);
                    // Fallback to default settings
                    settings = {
                        swingRange: 90, swingFreq: 8, swingTargetX: 5,
                        zigzagAmp: 2, zigzagFreq: 6, zigzagTargetX: 5, zigzagTargetY: 3,
                        pendulumRange: 60, pendulumSpeed: 2,
                        waveAmp: 1.5, waveFreq: 4, waveTargetX: 4, waveTargetY: 2,
                        bounceHeight: 2, bounceFreq: 4,
                        spiralRadius: 3, spiralRotations: 6,
                        slideDistance: 10, rotateCycles: 1
                    };
                }
                
                const startTime = Date.now();
                
                const interval = setInterval(() => {
                    const currentTime = Date.now();
                    const elapsed = (currentTime - startTime) / 1000 * speed;
                    let progress = (elapsed % duration) / duration;
                    
                    if (!loop && elapsed > duration) {
                        clearInterval(interval);
                        return;
                    }
                    
                    const easeInOut = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    const easedProgress = easeInOut(progress);

                    const originalPos = layer.getAttribute('position');
                    const originalRot = layer.getAttribute('rotation');
                    const originalScale = layer.getAttribute('scale');
                    const origX = originalPos.x, origY = originalPos.y, origZ = originalPos.z;
                    const origRotX = originalRot.x, origRotY = originalRot.y, origRotZ = originalRot.z;
                    const origScaleX = originalScale.x, origScaleY = originalScale.y, origScaleZ = originalScale.z;

                    let finalX = origX, finalY = origY, finalZ = origZ;
                    let finalRotX = origRotX, finalRotY = origRotY, finalRotZ = origRotZ;
                    let finalScaleX = origScaleX, finalScaleY = origScaleY, finalScaleZ = origScaleZ;
                    let finalOpacity = 1;
                
                    // Apply custom animation if enabled
                    if (enableCustom) {
                        try {
                            const customStart = JSON.parse(layer.getAttribute('data-custom-start').replace(/&quot;/g, '"'));
                            const customEnd = JSON.parse(layer.getAttribute('data-custom-end').replace(/&quot;/g, '"'));
                            
                            finalX = customStart.x + (customEnd.x - customStart.x) * easedProgress;
                            finalY = customStart.y + (customEnd.y - customStart.y) * easedProgress;
                            finalZ = customStart.z + (customEnd.z - customStart.z) * easedProgress;
                            
                            const customScale = customStart.scale + (customEnd.scale - customStart.scale) * easedProgress;
                            finalScaleX = finalScaleY = finalScaleZ = customScale;
                            
                            finalOpacity = customStart.opacity + (customEnd.opacity - customStart.opacity) * easedProgress;
                            finalRotZ = customStart.rotation + (customEnd.rotation - customStart.rotation) * easedProgress;
                        } catch (e) {
                            console.error('Error parsing custom animation data:', e);
                        }
                    }
                    
                    // Apply special effects with user-controlled settings
                    if (specialEffect !== 'none') {
                        switch (specialEffect) {
                            case 'swingToTarget':
                                const swingAmplitude = (1 - easedProgress) * settings.swingRange;
                                const swingAngle = Math.sin(progress * settings.swingFreq * Math.PI) * swingAmplitude;
                                finalRotZ += swingAngle;

                                if (!enableCustom) {
                                    finalX += settings.swingTargetX * easedProgress;
                                }
                                break;

                            case 'zigzagToTarget':
                                const zigzagAmplitude = (1 - easedProgress) * settings.zigzagAmp;
                                const zigzagOffset = Math.sin(progress * settings.zigzagFreq * Math.PI) * zigzagAmplitude;
                                finalX += zigzagOffset;

                                if (!enableCustom) {
                                    finalX += settings.zigzagTargetX * easedProgress;
                                    finalY += settings.zigzagTargetY * easedProgress;
                                }
                                break;

                            case 'pendulumMove':
                                const pendulumAngle = Math.sin(elapsed * settings.pendulumSpeed) * settings.pendulumRange;
                                finalRotZ += pendulumAngle;
                                break;

                            case 'waveToTarget':
                                const waveY = Math.sin(progress * settings.waveFreq * Math.PI) * settings.waveAmp * (1 - easedProgress);
                                finalY += waveY;
                                finalRotZ += (waveY * 0.2);

                                if (!enableCustom) {
                                    finalX += settings.waveTargetX * easedProgress;
                                    finalY += settings.waveTargetY * easedProgress;
                                }
                                break;

                            case 'elasticMove':
                                const scaleElastic = 1 + Math.sin(progress * 10) * 0.1 * (1 - progress);
                                finalScaleX *= scaleElastic;
                                finalScaleY *= scaleElastic;
                                finalScaleZ *= scaleElastic;

                                if (!enableCustom) {
                                    const elasticEase = (t) => {
                                        if (t === 0) return 0;
                                        if (t === 1) return 1;
                                        const c4 = (2 * Math.PI) / 3;
                                        return t < 0.5
                                            ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c4)) / 2
                                            : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c4)) / 2 + 1;
                                    };
                                    const elasticProgress = elasticEase(progress);
                                    finalX += 3 * elasticProgress;
                                    finalY += 3 * elasticProgress;
                                }
                                break;

                            case 'slideDown':
                                finalY += settings.slideDistance * (1 - easedProgress);
                                break;
                            case 'slideUp':
                                finalY -= settings.slideDistance * (1 - easedProgress);
                                break;
                            case 'slideLeft':
                                finalX += settings.slideDistance * (1 - easedProgress);
                                break;
                            case 'slideRight':
                                finalX -= settings.slideDistance * (1 - easedProgress);
                                break;
                            case 'fadeIn':
                                finalOpacity *= easedProgress;
                                break;
                            case 'scaleIn':
                                const scaleInFactor = easedProgress;
                                finalScaleX *= scaleInFactor;
                                finalScaleY *= scaleInFactor;
                                finalScaleZ *= scaleInFactor;
                                break;
                            case 'rotate':
                                finalRotZ += easedProgress * 360 * settings.rotateCycles;
                                break;
                            case 'bounce':
                                const bounceY = Math.abs(Math.sin(easedProgress * Math.PI * settings.bounceFreq)) * settings.bounceHeight;
                                finalY += bounceY;
                                break;
                            case 'spiral':
                                const spiralRadius = settings.spiralRadius * (1 - easedProgress);
                                const spiralAngle = easedProgress * Math.PI * settings.spiralRotations;
                                finalX += spiralRadius * Math.cos(spiralAngle);
                                finalY += spiralRadius * Math.sin(spiralAngle);
                                break;
                        }
                    }
                    
                    // Update layer position, rotation, and scale
                    layer.setAttribute('position', finalX + ' ' + finalY + ' ' + finalZ);
                    layer.setAttribute('rotation', finalRotX + ' ' + finalRotY + ' ' + finalRotZ);
                    layer.setAttribute('scale', finalScaleX + ' ' + finalScaleY + ' ' + finalScaleZ);
                    
                    // Update opacity if needed
                    if (specialEffect === 'fadeIn' || enableCustom) {
                        layer.setAttribute('material', 'transparent: true; opacity: ' + finalOpacity);
                    }
                    
                }, 16); // ~60fps
                
                animationIntervals.push(interval);
            }
        });
    }
    
    function stopAllAnimations() {
        animationIntervals.forEach(interval => clearInterval(interval));
        animationIntervals = [];
    }
    
    </script>
</body>
</html>