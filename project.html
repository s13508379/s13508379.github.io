<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>project - AR Experience</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
    <style>
        .ar-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        .ar-controls button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background: #0066cc;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .ar-controls button:hover {
            background: #0052a3;
        }
    </style>
</head>

<body>
    <div class="ar-controls">
        <button onclick="playAllAnimations()">Play All Animations</button>
        <button onclick="stopAllAnimations()">Stop Animations</button>
    </div>

    <a-scene vr-mode-ui="enabled: false" embedded
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3; trackingMethod: best; maxDetectionRate: 60; canvasWidth: 640; canvasHeight: 480;"
        renderer="logarithmicDepthBuffer: true; colorManagement: true; sortObjects: true;"
        background="color: #000000; transparent: true">

        <a-assets>
            <img id="img-0" src="images/allimg.png" crossorigin="anonymous">
            <audio id="audio-audio_1752560588117_l2dxn0i1e" src="audio/sound.mp3" preload="auto"></audio>
            <audio id="audio-audio_1752560588119_q4097830t" src="audio/title.mp3" preload="auto"></audio>
            <audio id="audio-audio_1752560588119_bo1ooyhvh" src="audio/title-large.mp3" preload="auto"></audio>
        </a-assets>

        <a-marker type="pattern" url="pattern-project-qr-code.patt">
            <a-plane id="layer-0" src="#img-0" position="0.00 0.00 0.00" rotation="94.00 6.00 0.00"
                scale="1.00 1.00 1.00" material="transparent: true; opacity: 1.00" data-animation-enabled="true"
                data-special-effect="swingToTarget" data-animation-speed="1" data-animation-duration="2"
                data-loop-animation="true"
                data-custom-start="{&quot;x&quot;:0,&quot;y&quot;:0.9,&quot;z&quot;:0,&quot;scale&quot;:1,&quot;opacity&quot;:1,&quot;rotation&quot;:0}"
                data-custom-end="{&quot;x&quot;:0,&quot;y&quot;:0.9,&quot;z&quot;:0,&quot;scale&quot;:1,&quot;opacity&quot;:1,&quot;rotation&quot;:0}"
                data-special-settings="{&quot;swingRange&quot;:40,&quot;swingFreq&quot;:4,&quot;swingTargetX&quot;:5,&quot;zigzagAmp&quot;:2,&quot;zigzagFreq&quot;:6,&quot;zigzagTargetX&quot;:5,&quot;zigzagTargetY&quot;:3,&quot;pendulumRange&quot;:60,&quot;pendulumSpeed&quot;:2,&quot;waveAmp&quot;:1.5,&quot;waveFreq&quot;:4,&quot;waveTargetX&quot;:4,&quot;waveTargetY&quot;:2,&quot;bounceHeight&quot;:2,&quot;bounceFreq&quot;:4,&quot;spiralRadius&quot;:3,&quot;spiralRotations&quot;:6,&quot;slideDistance&quot;:10,&quot;rotateCycles&quot;:1}"
                data-original-position="{&quot;x&quot;:0,&quot;y&quot;:0,&quot;z&quot;:0}"
                data-original-rotation="{&quot;x&quot;:1.6406094968746698,&quot;y&quot;:0.10471975511965977,&quot;z&quot;:0}"
                data-original-scale="{&quot;x&quot;:1,&quot;y&quot;:1,&quot;z&quot;:1}" data-original-opacity="1.00">
            </a-plane>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        let animationIntervals = [];
        let audioTracks = [];
        let markerVisible = false;
        let backgroundAudioTrack = null;
        let currentSequentialIndex = 0;
        let sequenceLoopActive = false;
        let currentTrackTimeout = null;
        let currentIndex = 0;

        // Initialize audio tracks from HTML audio elements
        function initializeAudioTracks() {
            audioTracks = [];
            audioTracks.push({
                id: "audio_1752560588117_l2dxn0i1e",
                name: "sound.mp3",
                audio: document.getElementById("audio-audio_1752560588117_l2dxn0i1e"),
                playOrder: 0,
                loop: false,
                isBackground: true,
                startTime: 0,
                endTime: 18.133333,
                timelineMode: false,
                volume: 0.8,
                isPlaying: false
            });
            audioTracks.push({
                id: "audio_1752560588119_q4097830t",
                name: "title.mp3",
                audio: document.getElementById("audio-audio_1752560588119_q4097830t"),
                playOrder: 1,
                loop: false,
                isBackground: false,
                startTime: 0,
                endTime: 3.584,
                timelineMode: false,
                volume: 0.8,
                isPlaying: false
            });
            audioTracks.push({
                id: "audio_1752560588119_bo1ooyhvh",
                name: "title-large.mp3",
                audio: document.getElementById("audio-audio_1752560588119_bo1ooyhvh"),
                playOrder: 2,
                loop: true,
                isBackground: false,
                startTime: 2,
                endTime: 3.584,
                timelineMode: true,
                volume: 0.8,
                isPlaying: false
            });

            // Set audio properties
            audioTracks.forEach(track => {
                track.audio.volume = track.volume;
                if (track.isBackground) {
                    track.audio.loop = true; // Keep loop for background audio
                    backgroundAudioTrack = track;
                }
            });

            console.log('Initialized', audioTracks.length, 'audio tracks');
        }

        // Call initialization when page loads
        window.addEventListener('load', initializeAudioTracks);

        document.querySelector('a-marker').addEventListener('markerFound', function () {
            markerVisible = true;
            console.log('Marker found - starting animations and audio');

            // Start background audio if exists
            if (backgroundAudioTrack && backgroundAudioTrack.audio) {
                backgroundAudioTrack.audio.play().catch(e => console.log('Background audio autoplay blocked:', e));
                backgroundAudioTrack.isPlaying = true;
            }

            // Auto-start sequential audio playback based on settings
            playSequentialAudio();
            playAllAnimations();
        });

        document.querySelector('a-marker').addEventListener('markerLost', function () {
            markerVisible = false;
            console.log('Marker lost - stopping animations and audio');

            // Stop all audio
            stopAllAudio();
            stopAllAnimations();
        });

        function playNextInSequence(tracks) {
            if (!sequenceLoopActive || !markerVisible) return;

            // Clear any existing timeout before starting new track
            if (currentTrackTimeout) {
                clearTimeout(currentTrackTimeout);
                currentTrackTimeout = null;
            }

            if (currentSequentialIndex >= tracks.length) {
                console.log('Restarting title sequence... (index was', currentSequentialIndex, 'of', tracks.length, ')');
                currentSequentialIndex = 0;
                // No delay needed for continuous looping of titles
            }

            const track = tracks[currentSequentialIndex];
            console.log('Playing track:', track.name, 'Order:', track.playOrder, 'Index:', currentSequentialIndex);


            if (currentSequentialIndex < tracks.length) {
                console.log(currentSequentialIndex, 'tacks:', tracks.length)
                playTrack(track, () => {
                    console.log(currentSequentialIndex, 'tacks:', tracks.length)
                    console.log('Track completed:', track.name, 'Moving to index:', currentSequentialIndex + 1);

                    currentSequentialIndex++;

                    currentTrackTimeout = setTimeout(() => {
                        if (sequenceLoopActive && markerVisible) {
                            playNextInSequence(tracks);
                        }
                    }, 200); // 200ms delay between tracks
                });
            } else {
                console.log(currentSequentialIndex, 'tacks:', tracks.length)
                const loopTracks = getLoopGroupTracks();

                if (loopTracks.length > 0) {
                    console.log('Starting loop phase with', loopTracks.length, 'looping tracks');
                    playLoopSequence(loopTracks);
                } else {
                    console.log('No looping tracks found, sequence complete');
                    sequenceLoopActive = false;
                }
            }
        }

        function playLoopSequence(loopTracks) {
            if (!sequenceLoopActive || !markerVisible) return;

            // 如果没有定义loopIndex，初始化为0
            if (typeof currentLoopIndex === 'undefined') {
                window.currentLoopIndex = 0;
            }

            // Clear any existing timeout
            if (currentTrackTimeout) {
                clearTimeout(currentTrackTimeout);
                currentTrackTimeout = null;
            }

            // 重置循环索引如果超出范围
            if (currentLoopIndex >= loopTracks.length) {
                currentLoopIndex = 0;
                console.log('Restarting loop sequence...');
            }

            const track = loopTracks[currentLoopIndex];
            console.log('Playing loop track:', track.name, 'Loop index:', currentLoopIndex, 'of', loopTracks.length);

            playTrack(track, () => {
                console.log('Loop track completed:', track.name);

                // 移动到下一个循环轨道
                currentLoopIndex++;

                // 继续循环序列
                currentTrackTimeout = setTimeout(() => {
                    if (sequenceLoopActive && markerVisible) {
                        playLoopSequence(loopTracks);
                    }
                }, 200);
            });
        }

        function getLoopGroupTracks() {
            return audioTracks
                .filter(t => t.loop && !t.isBackground)
                .sort((a, b) => a.playOrder - b.playOrder);
        }

        function playSequentialAudio() {
            if (audioTracks.length === 0) {
                console.log('No audio tracks available');
                return;
            }

            // Clear any existing timeout
            if (currentTrackTimeout) {
                clearTimeout(currentTrackTimeout);
                currentTrackTimeout = null;
            }

            // Don't stop background music, only stop regular tracks
            audioTracks.forEach(track => {
                if (!track.isBackground && track.isPlaying) {
                    track.audio.pause();
                    track.isPlaying = false;
                    if (track.timelineMode && track.startTime > 0) {
                        track.audio.currentTime = track.startTime;
                    } else {
                        track.audio.currentTime = 0;
                    }
                }
            });

            const regularTracks = audioTracks
                .filter(track => !track.isBackground && track.playOrder > 0)
                .sort((a, b) => a.playOrder - b.playOrder);

            if (regularTracks.length === 0) {
                console.log('No regular tracks to play');
                return;
            }

            // 重置索引
            currentSequentialIndex = 0;
            window.currentLoopIndex = 0; // 初始化循环索引
            sequenceLoopActive = true;

            console.log('Starting sequential audio with', regularTracks.length, 'tracks');
            console.log('Loop tracks:', getLoopGroupTracks().length);

            playNextInSequence(regularTracks);
        }

        function stopAllAudio() {
            sequenceLoopActive = false;

            // Clear any pending timeouts
            if (currentTrackTimeout) {
                clearTimeout(currentTrackTimeout);
                currentTrackTimeout = null;
            }

            audioTracks.forEach(track => {
                track.audio.pause();
                track.isPlaying = false;

                if (track.timelineMode && track.startTime > 0) {
                    track.audio.currentTime = track.startTime;
                } else {
                    track.audio.currentTime = 0;
                }
            });
            currentSequentialIndex = 0;
            if (typeof currentLoopIndex !== 'undefined') {
                currentLoopIndex = 0;
            }

            console.log('All audio stopped');
        }

        function playTrack(track, onComplete) {
            if (!sequenceLoopActive || !markerVisible) return;

            console.log('Starting track:', track.name, 'Timeline mode:', track.timelineMode, 'Start:', track.startTime, 'End:', track.endTime);

            // Set start time if timeline mode
            if (track.timelineMode && track.startTime > 0) {
                track.audio.currentTime = track.startTime;
            } else {
                track.audio.currentTime = 0;
            }

            track.audio.play().catch(e => console.log('Audio play error:', e));
            track.isPlaying = true;

            // Calculate duration for this track
            let trackDuration;
            if (track.timelineMode && track.endTime && track.startTime) {
                trackDuration = (track.endTime - track.startTime) * 1000; // Convert to milliseconds
                console.log('Track duration (timeline):', trackDuration + 'ms');
            } else if (track.audio.duration) {
                trackDuration = track.audio.duration * 1000; // Convert to milliseconds
                console.log('Track duration (full):', trackDuration + 'ms');
            } else {
                trackDuration = 3000; // Fallback to 3 seconds
                console.log('Track duration (fallback):', trackDuration + 'ms');
            }

            // Set up end listener
            const onEnded = () => {
                console.log('Track ended:', track.name);
                track.audio.removeEventListener('ended', onEnded);
                track.audio.removeEventListener('timeupdate', onTimeUpdate);
                track.isPlaying = false;

                if (onComplete) {
                    onComplete();
                }
            };

            const onTimeUpdate = () => {
                if (track.timelineMode && track.endTime && track.audio.currentTime >= track.endTime) {
                    console.log('Track reached end time:', track.name, 'at', track.audio.currentTime);
                    track.audio.pause();
                    onEnded();
                }
            };

            track.audio.addEventListener('ended', onEnded);
            if (track.timelineMode && track.endTime) {
                track.audio.addEventListener('timeupdate', onTimeUpdate);
            }

            // Fallback timeout in case audio events don't fire properly
            currentTrackTimeout = setTimeout(() => {
                if (track.isPlaying) {
                    console.log('Track timeout reached:', track.name);
                    track.audio.pause();
                    onEnded();
                }
            }, trackDuration + 100); // Add 100ms buffer
        }


        function toggleBackgroundAudio() {
            if (!backgroundAudioTrack) {
                console.log('No background audio track available');
                return;
            }

            if (backgroundAudioTrack.isPlaying) {
                backgroundAudioTrack.audio.pause();
                backgroundAudioTrack.isPlaying = false;
                console.log('Background audio paused');
            } else {
                backgroundAudioTrack.audio.play().catch(e => console.log('Background audio play error:', e));
                backgroundAudioTrack.isPlaying = true;
                console.log('Background audio playing');
            }
        }

        function playAllAnimations() {
            stopAllAnimations();
            const layers = document.querySelectorAll('[id^="layer-"]');
            layers.forEach(layer => {
                const enableCustom = layer.getAttribute('data-animation-enabled') === 'true';
                const specialEffect = layer.getAttribute('data-special-effect');

                if (enableCustom || specialEffect !== 'none') {
                    const speed = parseFloat(layer.getAttribute('data-animation-speed'));
                    const duration = parseFloat(layer.getAttribute('data-animation-duration'));
                    const loop = layer.getAttribute('data-loop-animation') === 'true';

                    // Parse special effect settings
                    let settings = {};
                    try {
                        settings = JSON.parse(layer.getAttribute('data-special-settings').replace(/&quot;/g, '"'));
                    } catch (e) {
                        console.error('Error parsing special effect settings:', e);
                        // Fallback to default settings
                        settings = {
                            swingRange: 90, swingFreq: 8, swingTargetX: 5,
                            zigzagAmp: 2, zigzagFreq: 6, zigzagTargetX: 5, zigzagTargetY: 3,
                            pendulumRange: 60, pendulumSpeed: 2,
                            waveAmp: 1.5, waveFreq: 4, waveTargetX: 4, waveTargetY: 2,
                            bounceHeight: 2, bounceFreq: 4,
                            spiralRadius: 3, spiralRotations: 6,
                            slideDistance: 10, rotateCycles: 1
                        };
                    }

                    const startTime = Date.now();

                    const interval = setInterval(() => {
                        const currentTime = Date.now();
                        const elapsed = (currentTime - startTime) / 1000 * speed;
                        let progress = (elapsed % duration) / duration;

                        if (!loop && elapsed > duration) {
                            clearInterval(interval);
                            return;
                        }

                        const easeInOut = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                        const easedProgress = easeInOut(progress);

                        const originalPos = layer.getAttribute('position');
                        const originalRot = layer.getAttribute('rotation');
                        const originalScale = layer.getAttribute('scale');
                        const origX = originalPos.x, origY = originalPos.y, origZ = originalPos.z;
                        const origRotX = originalRot.x, origRotY = originalRot.y, origRotZ = originalRot.z;
                        const origScaleX = originalScale.x, origScaleY = originalScale.y, origScaleZ = originalScale.z;

                        let finalX = origX, finalY = origY, finalZ = origZ;
                        let finalRotX = origRotX, finalRotY = origRotY, finalRotZ = origRotZ;
                        let finalScaleX = origScaleX, finalScaleY = origScaleY, finalScaleZ = origScaleZ;
                        let finalOpacity = 1;

                        // Apply custom animation if enabled
                        if (enableCustom) {
                            try {
                                const customStart = JSON.parse(layer.getAttribute('data-custom-start').replace(/&quot;/g, '"'));
                                const customEnd = JSON.parse(layer.getAttribute('data-custom-end').replace(/&quot;/g, '"'));

                                finalX = customStart.x + (customEnd.x - customStart.x) * easedProgress;
                                finalY = customStart.y + (customEnd.y - customStart.y) * easedProgress;
                                finalZ = customStart.z + (customEnd.z - customStart.z) * easedProgress;

                                const customScale = customStart.scale + (customEnd.scale - customStart.scale) * easedProgress;
                                finalScaleX = finalScaleY = finalScaleZ = customScale;

                                finalOpacity = customStart.opacity + (customEnd.opacity - customStart.opacity) * easedProgress;
                                finalRotZ = customStart.rotation + (customEnd.rotation - customStart.rotation) * easedProgress;
                            } catch (e) {
                                console.error('Error parsing custom animation data:', e);
                            }
                        }

                        // Apply special effects with user-controlled settings
                        if (specialEffect !== 'none') {
                            switch (specialEffect) {
                                case 'swingToTarget':
                                    const swingAmplitude = (1 - easedProgress) * settings.swingRange;
                                    const swingAngle = Math.sin(progress * settings.swingFreq * Math.PI) * swingAmplitude;
                                    finalRotZ += swingAngle;

                                    if (!enableCustom) {
                                        finalX += settings.swingTargetX * easedProgress;
                                    }
                                    break;

                                case 'zigzagToTarget':
                                    const zigzagAmplitude = (1 - easedProgress) * settings.zigzagAmp;
                                    const zigzagOffset = Math.sin(progress * settings.zigzagFreq * Math.PI) * zigzagAmplitude;
                                    finalX += zigzagOffset;

                                    if (!enableCustom) {
                                        finalX += settings.zigzagTargetX * easedProgress;
                                        finalY += settings.zigzagTargetY * easedProgress;
                                    }
                                    break;

                                case 'pendulumMove':
                                    const pendulumAngle = Math.sin(elapsed * settings.pendulumSpeed) * settings.pendulumRange;
                                    finalRotZ += pendulumAngle;
                                    break;

                                case 'waveToTarget':
                                    const waveY = Math.sin(progress * settings.waveFreq * Math.PI) * settings.waveAmp * (1 - easedProgress);
                                    finalY += waveY;
                                    finalRotZ += (waveY * 0.2);

                                    if (!enableCustom) {
                                        finalX += settings.waveTargetX * easedProgress;
                                        finalY += settings.waveTargetY * easedProgress;
                                    }
                                    break;

                                case 'elasticMove':
                                    const scaleElastic = 1 + Math.sin(progress * 10) * 0.1 * (1 - progress);
                                    finalScaleX *= scaleElastic;
                                    finalScaleY *= scaleElastic;
                                    finalScaleZ *= scaleElastic;

                                    if (!enableCustom) {
                                        const elasticEase = (t) => {
                                            if (t === 0) return 0;
                                            if (t === 1) return 1;
                                            const c4 = (2 * Math.PI) / 3;
                                            return t < 0.5
                                                ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c4)) / 2
                                                : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c4)) / 2 + 1;
                                        };
                                        const elasticProgress = elasticEase(progress);
                                        finalX += 3 * elasticProgress;
                                        finalY += 3 * elasticProgress;
                                    }
                                    break;

                                case 'slideDown':
                                    finalY += settings.slideDistance * (1 - easedProgress);
                                    break;
                                case 'slideUp':
                                    finalY -= settings.slideDistance * (1 - easedProgress);
                                    break;
                                case 'slideLeft':
                                    finalX += settings.slideDistance * (1 - easedProgress);
                                    break;
                                case 'slideRight':
                                    finalX -= settings.slideDistance * (1 - easedProgress);
                                    break;
                                case 'fadeIn':
                                    finalOpacity *= easedProgress;
                                    break;
                                case 'scaleIn':
                                    const scaleInFactor = easedProgress;
                                    finalScaleX *= scaleInFactor;
                                    finalScaleY *= scaleInFactor;
                                    finalScaleZ *= scaleInFactor;
                                    break;
                                case 'rotate':
                                    finalRotZ += easedProgress * 360 * settings.rotateCycles;
                                    break;
                                case 'bounce':
                                    const bounceY = Math.abs(Math.sin(easedProgress * Math.PI * settings.bounceFreq)) * settings.bounceHeight;
                                    finalY += bounceY;
                                    break;
                                case 'spiral':
                                    const spiralRadius = settings.spiralRadius * (1 - easedProgress);
                                    const spiralAngle = easedProgress * Math.PI * settings.spiralRotations;
                                    finalX += spiralRadius * Math.cos(spiralAngle);
                                    finalY += spiralRadius * Math.sin(spiralAngle);
                                    break;
                            }
                        }

                        // Update layer position, rotation, and scale
                        layer.setAttribute('position', finalX + ' ' + finalY + ' ' + finalZ);
                        layer.setAttribute('rotation', finalRotX + ' ' + finalRotY + ' ' + finalRotZ);
                        layer.setAttribute('scale', finalScaleX + ' ' + finalScaleY + ' ' + finalScaleZ);

                        // Update opacity if needed
                        if (specialEffect === 'fadeIn' || enableCustom) {
                            layer.setAttribute('material', 'transparent: true; opacity: ' + finalOpacity);
                        }

                    }, 16); // ~60fps

                    animationIntervals.push(interval);
                }
            });
        }

        function stopAllAnimations() {
            animationIntervals.forEach(interval => clearInterval(interval));
            animationIntervals = [];
        }

    </script>
</body>

</html>